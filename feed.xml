<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[r7kamura/diary]]></title><description><![CDATA[r7kamura's daily working log.]]></description><link>https://r7kamura.github.io/diary/</link><generator>r7kamura/diary</generator><lastBuildDate>Sun, 07 Aug 2022 06:59:48 GMT</lastBuildDate><atom:link href="https://r7kamura.github.io/diary/feed.xml" rel="self" type="application/rss+xml"/><item><title><![CDATA[2022-08-06]]></title><description><![CDATA[r7kamura's working log on 2022-08-06]]></description><link>https://r7kamura.github.io/diary/articles/93</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/93</guid><pubDate>Fri, 05 Aug 2022 21:23:11 GMT</pubDate><content:encoded><![CDATA[<hr><p><img src="https://user-images.githubusercontent.com/111689/183218594-34042320-c476-44c8-8de9-e7d47f9d0c28.png" alt="image"></p>
<p>if-elseif-else-endをHighlightする作業を進めている</p><hr><p><img src="https://user-images.githubusercontent.com/111689/183224573-7adea94a-7740-47c2-8c60-84235d3219c1.gif" alt="1"></p><hr><p><img src="https://user-images.githubusercontent.com/111689/183226158-fd6a65ee-6062-45d2-8d44-d96dc068872e.png" alt="image"></p>
<p>子供みたいなコードになった</p><hr><p><img src="https://user-images.githubusercontent.com/111689/183244677-ca6e409e-ca4f-4724-aa4b-10654e3a3d06.gif" alt="1"></p>]]></content:encoded></item><item><title><![CDATA[2022-08-05]]></title><description><![CDATA[r7kamura's working log on 2022-08-05]]></description><link>https://r7kamura.github.io/diary/articles/92</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/92</guid><pubDate>Thu, 04 Aug 2022 21:03:13 GMT</pubDate><content:encoded><![CDATA[<hr><p>空いた時間にVSCodeのRuby用拡張を進捗させたい。</p><hr><p><code>Promise&#x3C;T></code> の代わりに <code>Thenable&#x3C;T></code> と記載している例をVSCodeのコード例でよく見るが、これはjQuery.Deferredなど他の各種Promise系のやつでも受け入れるための型クラスらしい。</p><hr><p>DocumentSelector</p>
<p>その拡張がどういうドキュメント (VSCodeがタブとかで開くテキストの単位) で有効になるかを絞り込むための条件を指定する単位。次の2つの情報を持てるらしい</p>
<ul>
<li>どのファイルタイプか
<ul>
<li>e.g. <code>ruby</code></li>
</ul>
</li>
<li>どのschemeか
<ul>
<li>e.g. <code>file</code>, <code>untitled</code></li>
<li>現実的にはファイルが永続化されているかどうか (適当に新規タブで開いたやつはuntitled) を判別するのに使われることがほとんどっぽい?</li>
</ul>
</li>
</ul>
<p><a href="https://code.visualstudio.com/api/references/document-selector">https://code.visualstudio.com/api/references/document-selector</a></p>
<p>Example from lsp-example:</p>
<pre><code class="language-js">[
  { scheme: "file", language: "plaintext" }
]
</code></pre>
<p>Example from vscode-ruby-client:</p>
<pre><code class="language-js">[
  { scheme: "file", language: "ruby" },
  { scheme: "untitled", language: "ruby" },
]
</code></pre><hr><p>vscode packageのこれをClientOptionsに指定したものの、詳しく調べていない。</p>
<pre><code>workspace.createFileSystemWatcher
</code></pre><hr><p>vscode-ruby-clientだと、clientOptionsのmiddleware.workspaceを指定している。これはmulti workspaceのための何かだろうか。</p><hr><p>default import/export おさらいのコーナー。</p>
<pre><code class="language-typescript">import * as path from "path";
</code></pre>
<p>例えば、上のコードを下のコードのように書き換えてみる。</p>
<pre><code class="language-typescript">import path from "path";
</code></pre>
<p>すると、次のようなエラーが確認できる。</p>
<pre><code>Module '"path"' can only be default-imported using the 'esModuleInterop' flagts(1259)
path.d.ts(167, 5): This module is declared with using 'export =', and can only be used with a default import when using the 'esModuleInterop' flag.
</code></pre>
<p>これは、JavaScriptにおける幾つかのモジュールシステムのdefault import/exportに関する挙動が異なることが原因で……</p>
<p>TypeScriptは何も設定していない場合、ES6風のモジュールシステムを前提に動くので、</p>
<pre><code class="language-typescript">import a from "b"
</code></pre>
<p>に対しては、</p>
<pre><code class="language-typescript">const a = require("b").default
</code></pre>
<p>のようなコードを生成し、</p>
<pre><code class="language-typescript">import * as a from "b"
</code></pre>
<p>に対しては、</p>
<pre><code class="language-typescript">const a = require("b")
</code></pre>
<p>のようなコードを生成する。</p>
<p>path moduleは export default してはおらず普通に export しているので、後者の方法を使う必要があるという話。</p>
<p>このTypeScriptの挙動は</p>
<pre><code class="language-json">{ "esModuleInterop": true }
</code></pre>
<p>のように設定すると変えることもできる。</p><hr><p>lsp-exampleは、トップレベルのパッケージがVSCode extensionとして配布される形になっている。</p>
<p>というのも、次のようにサーバープロセスを起動するためのパスが記載されているので、拡張のルートディレクトリから見て ./server/out/server.js というのがあることが分かる。</p>
<pre><code class="language-typescript">const serverModule = context.asAbsolutePath(
	path.join("server", "out", "server.js")
);
</code></pre><hr><p>vscode-ruby-clientが次のようになっているので</p>
<pre><code class="language-typescript">client = new LanguageClient('ruby', 'Ruby', serverOptions, clientOptions);
client.registerProposedFeatures();
</code></pre>
<p>registerProposedFeaturesの定義を見に行った。現在は空の配列が返ってくるだけだが、過去には</p>
<pre><code class="language-typescript">[
  new pd.DiagnosticFeature(client),
  new nb.NotebookDocumentSyncFeature(client)
]
</code></pre>
<p>のような配列が返ることもあったらしい。要はβ版の新機能を取り込むための処理だろうか。</p><hr><p>vscode-ruby-client/srcを見るとlinterやらcompletionやらが転がっているが、これは過去にクライアント側で正規表現を用いて機能が実装されていた頃の名残で、現在はどうやら参照されていないように見える。</p><hr><p>つまりクライアント側はほぼ何も実装しなくても良い感じっぽい。</p><hr><p>lsp-exampleのサーバー側の実装を少しずつ読んでいる。</p>
<ul>
<li>onInitializeで、clientのcapabilitiesを見ながらserverのcapabilitiesを返す</li>
<li>onInitializedで、必要な初期化処理をやっていく。connection.listenとか</li>
</ul>
<p>この拡張の機能に関するデフォルトの設定があり、これが各テキストドキュメントごとのデフォルトの設定になる。テキストドキュメント単位で設定値を上書きすることが可能なので、こうなっている。テキストドキュメントのURIをIDとして、Mapオブジェクトを利用して設定値のキャッシュを持っている。</p>
<p>設定値はクライアントが保持していて、サーバーがそれを知るには connection.workspace.getConfigurationで問い合わせる必要がある。この問い合わせ結果を上述のキャッシュに保存しておいているという仕組み。既に問い合わせ済みであればそのキャッシュから取得する。設定値変更イベントがクライアントで発生した場合、それがconnection経由で伝わってくるので、その場合サーバーはキャッシュを全部消す。これにより、次回の設定値取得時には新たにクライアントから取得しにいくようになるという寸法。</p>
<p>テキストドキュメントが閉じられる際には、キャッシュからも設定値を消す。現在開かれているテキストドキュメントの設定値しか保持しないことで、サイズを小さく抑えるため?</p>
<p>設定が変更された場合は、diagnosticsの検査をいちからやり直す。設定値の変化により検査結果が変わることがあるため。</p><hr><p>試しにhighlight機能を追加してみる。</p>
<p>まずonInitializeで返すcapabilitiesにプロパティを追加して、documentHighlightProviderに対応していることを示す。</p>
<pre><code class="language-diff">diff --git a/server/src/server.ts b/server/src/server.ts
index 8e1ddf8..5b83ad7 100644
--- a/server/src/server.ts
+++ b/server/src/server.ts
@@ -54,6 +54,7 @@ connection.onInitialize((params: InitializeParams) => {
       completionProvider: {
         resolveProvider: true,
       },
+      documentHighlightProvider: true,
     },
   };
   if (hasWorkspaceFolderCapability) {
</code></pre><hr><p>Provider.register(connection) を呼び出すタイミングとして、onInitializeとonInitializedの2パターンがあるけれど、どのProviderではどのタイミングを選べばいいのだろうか。</p>
<p>vscode-rubyでは、DocumentHighlightProviderはonInitializeで登録しているようだ。</p><hr><p><a href="https://github.com/microsoft/vscode-extension-samples">https://github.com/microsoft/vscode-extension-samples</a> にはdocumentHighlightProvider: trueとしている例は見当たらなかったので、実装例が無い。とりあえずvscode-rubyのやっている方法に従ってみることにする?</p><hr><p><img src="https://user-images.githubusercontent.com/111689/182980343-1afaca7e-b566-46ea-94c5-f5bbe2d4bc35.png" alt="image"></p>
<p>カーソルを合わせるとconnection.onDocumentHighlightで登録したコールバックが実行されることが無事確認できた。</p>
<p>Language Serverで出しているconsole.logは、Extension Development HostのOutputでセレクトボックスから「Ruby」を選ぶことで表示できた。これは……Clientで指定したnameが使われているっぽい?</p><hr><p><img src="https://user-images.githubusercontent.com/111689/182989897-e98a17c1-3854-40cd-880f-69919b5f9ac7.gif" alt="1"></p>
<p>自前実装で, endに対してDocumentHighlightが動くようになった。</p><hr><p>until, for, while についても対応しようとしたら親子関係というか木の構造が違うらしいことが分かった。それから、moduleもAもどちらもtypeはmoduleであるということも分かり、判定が大変そう。本当にキーワードかどうかはtoStringすれば判定できる。</p>]]></content:encoded></item><item><title><![CDATA[2022-08-04]]></title><description><![CDATA[r7kamura's working log on 2022-08-04]]></description><link>https://r7kamura.github.io/diary/articles/91</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/91</guid><pubDate>Wed, 03 Aug 2022 21:03:38 GMT</pubDate><content:encoded><![CDATA[<hr><p>ゼノブレイド3、かなりよく出来ている。1と2やる必要は全くない。</p>
<p>ムービーが長いという意見を聞いていたが、そこまで長過ぎるようには感じなかった。ここ数年でどんどん人類の嗜好形態が変化していて、長いムービーに耐えられなくなってきているというのはあると思う。</p>
<p>ちょっとHUDがうるさい感じはあるけど、ある程度は消すこともできるし、まあ許容範囲ではある。</p><hr><p><a href="https://dev.to/r7kamura/run-yard-as-rspec-3hnn">Run YARD as RSpec - DEV Community 👩‍💻👨‍💻</a>
これを書いた</p><hr><p><a href="https://github.com/r7kamura/yardspec">https://github.com/r7kamura/yardspec</a>
これを書いた</p>]]></content:encoded></item><item><title><![CDATA[2022-08-03]]></title><description><![CDATA[r7kamura's working log on 2022-08-03]]></description><link>https://r7kamura.github.io/diary/articles/90</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/90</guid><pubDate>Tue, 02 Aug 2022 22:21:10 GMT</pubDate><content:encoded><![CDATA[<hr><p>RuboCopのテンプレートサポート、autocorrectorの実装が難しくて、いい実装方法が見つかっていない。</p>
<ul>
<li><code>RuboCop::ProcessedSource</code> オブジェクトがテンプレート内のRubyのコード断片を表している</li>
<li>各Copはこのオブジェクトに対して <code>RuboCop::Cop::Offense</code> を生成する</li>
<li>offsetを指定してOffenseの位置情報をずらす</li>
</ul>
<p>というところまでは良いのだが、autocorrectを適用しようとすると、元々のソースコードに対してoffset付きで変換してほしいところが、Rubyのコード断片に対してoffset無しで変換が掛かってしまう。</p>
<p>Copがなぜかソースコードへの参照を持っているという設計が根本的な原因。</p>
<p>理想的には、こうなってほしい:</p>
<ol>
<li>テンプレートから、Rubyのコードを幾つか抽出する</li>
<li>それぞれのRubyのコードに対して、CopでOffenseを検出する</li>
<li>集めたOffense群の位置情報を、テンプレートのものに変換する</li>
<li>変換されたOffense群を、autocorrectorに掛ける</li>
<li>2に戻る (変換により新たに違反が検出されるようになるかもしれないため)</li>
</ol><hr><p>RuboCopのテンプレートサポート、満足のいく形に変更できた。</p><hr><p>vscodemicrosoft/vscode-extension-samples/lsp-sample を試す。</p>
<ul>
<li><a href="https://code.visualstudio.com/api/language-extensions/language-server-extension-guide">https://code.visualstudio.com/api/language-extensions/language-server-extension-guide</a></li>
</ul><hr><pre><code>npm install
npm run test
</code></pre>
<p>これが失敗</p>
<pre><code>error while loading shared libraries: libnss3.so: cannot open shared object file: No such file or directory
</code></pre><hr><pre><code>sudo apt install libnss3
</code></pre>
<pre><code>error while loading shared libraries: libatk-1.0.so.0: cannot open shared object file: No such file or directory
</code></pre>
<pre><code>sudo apt-get install libatk1.0-0
</code></pre>
<pre><code>error while loading shared libraries: libatk-bridge-2.0.so.0: cannot open shared object file: No such file or directory
</code></pre>
<pre><code>sudo apt-get install libatk-bridge2.0-0
</code></pre>
<pre><code>error while loading shared libraries: libgtk-3.so.0: cannot open shared object file: No such file or directory
</code></pre>
<pre><code>sudo apt install libgtk-3-0
</code></pre>
<pre><code>error while loading shared libraries: libgbm.so.1: cannot open shared object file: No such file or directory
</code></pre>
<pre><code>sudo apt-get install libgbm-dev
</code></pre>
<pre><code>$ npm run test

> lsp-sample@1.0.0 test
> sh ./scripts/e2e.sh

Found existing install in /home/r7kamura/ghq/github.com/r7kamura/vscode-ruby-toys/.vscode-test/vscode-linux-x64-1.69.2. Skipping download
[20605:0803/143117.330327:ERROR:ozone_platform_x11.cc(248)] Missing X server or $DISPLAY
[20605:0803/143117.330373:ERROR:env.cc(225)] The platform failed to initialize.  Exiting.
The futex facility returned an unexpected error code.
Exit code:   SIGABRT
Failed to run tests
</code></pre><hr><pre><code>export DISPLAY=$(cat /etc/resolv.conf | grep nameserver | awk '{print $2}'):0.0
</code></pre>
<ul>
<li><a href="https://blog.odaryo.com/2020/01/wsl2-xserver-export-display/">https://blog.odaryo.com/2020/01/wsl2-xserver-export-display/</a></li>
</ul>
<p>すぐには応答しなくなくったが変わらず。</p><hr><p>sourceforgeからVcXsrvをWindowsに入れた。XサーバーをWindowsに入れて、UbuntuのGUIをWindowsの上で描画してe2eテストを実行しようという試み。</p>
<ul>
<li><a href="https://sourceforge.net/projects/vcxsrv/">https://sourceforge.net/projects/vcxsrv/</a></li>
</ul><hr><p>VcXsrvを起動しながらやるとこれが出るようになった。</p>
<blockquote>
<p>Authorization required, but no authorization protocol specified</p>
</blockquote><hr><p>C:\Program Files\VcXsrv\xlaunch.exe から起動してaccess controlにチェックを入れながら進むと、バックグラウンドでVcXsrvが起動して、その状態だとようやく <code>npm run test</code> が成功するようになった。</p>
<p>この状態でも警告がかなり大量に出るのだが (主にdbus周り)、これは出るものらしい。一応dsubの設定をいれば消せるらしいのだが、まだ試していない。</p>
<p>Windows 11だとwslg?という仕組みでUbuntuのGUIの機能が特に何もせずWindowsで動くようだから、このXサーバー云々の話とDISPLAY環境変数の話は不要らしい。Windows11にしたい利点が初めて出てきて意外だ。</p><hr><p>今日は lsp-example を動かして、VSCodeで試すのとnpm run testでテストを動かすのをやった。GUIだから仕方無いけど、何か動いているものの地に足がついていない感じがして不安はある。</p>]]></content:encoded></item><item><title><![CDATA[2022-08-02]]></title><description><![CDATA[r7kamura's working log on 2022-08-02]]></description><link>https://r7kamura.github.io/diary/articles/89</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/89</guid><pubDate>Mon, 01 Aug 2022 21:04:04 GMT</pubDate><content:encoded><![CDATA[<hr><p>The pull request I have submitted to rubocop  for template language support is not yet completed and in draft status, so I would like to complete it today.</p><hr><p>I feel that perhaps there should be a rubocop-markdown that inspects Ruby code in Markdown code blocks, or rubocop-comment that inspects Ruby code in code comments.</p><hr><p>But the existing YARD and Markdown parsers cannot return ASTs with location information, so it's going to be difficult to achieve that.</p>]]></content:encoded></item><item><title><![CDATA[2022-08-01]]></title><description><![CDATA[r7kamura's working log on 2022-08-01]]></description><link>https://r7kamura.github.io/diary/articles/88</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/88</guid><pubDate>Mon, 01 Aug 2022 02:04:43 GMT</pubDate><content:encoded><![CDATA[<hr><p>コミックNewtypeの日付表記が曖昧なので、<code>"10月24日配信"</code> という文字列を去年の10月24日のTimeのインスタンスとして処理する機能をweneedfeedに追加した。</p><hr><p>rubocopのテンプレート言語サポートの実装を改善して、影響範囲をかなり小さくできた。</p><hr><p>weneedfeedのOPMLのXML生成時にエスケープの不具合を見つけて修正できた。</p>]]></content:encoded></item><item><title><![CDATA[2022-07-30]]></title><description><![CDATA[r7kamura's working log on 2022-07-30]]></description><link>https://r7kamura.github.io/diary/articles/86</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/86</guid><pubDate>Sat, 30 Jul 2022 01:08:32 GMT</pubDate><content:encoded><![CDATA[<hr><p>ひさしぶりにRustを書いていて全く分かっていない</p><hr><p>ファイル全体コピーが動くようになった。
<a href="https://github.com/r7kamura/gitcp">https://github.com/r7kamura/gitcp</a></p><hr><p><a href="https://dev.to/r7kamura/automate-refactoring-by-rubocop-todo-corrector-2mli">Automate refactoring by rubocop-todo-corrector - DEV Community 👩‍💻👨‍💻</a>
これを書いた。</p>]]></content:encoded></item><item><title><![CDATA[2022-07-29]]></title><description><![CDATA[r7kamura's working log on 2022-07-29]]></description><link>https://r7kamura.github.io/diary/articles/85</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/85</guid><pubDate>Fri, 29 Jul 2022 01:03:50 GMT</pubDate><content:encoded><![CDATA[<hr><p>Rails Upgrade Guidesを眺めていて、新しくCopが1つ欲しくなったのでrubocop-railsにPull Requestを投げた。</p><hr><p>GitHubのテンプレートリポジトリからファイルをコピーしてくるようなツールがほしいと思い、degitには幾らか不満があったので、そういうものを自作することにした。最終的にgitcpというcpのラッパーみたいなものでいくことにした。</p><hr><p>weneedfeed-comic-newtypeをつくろうとして、雛形がほしいなと思い、こういう経緯になっている。</p><hr><p>zipはファイル単位での圧縮なのでtar.gzに比べると当然圧縮率が低いが、zipには全体を解凍しなくても単一ファイルのみ解凍できるという特色があるので、そういう用途では速そうだ。</p>]]></content:encoded></item><item><title><![CDATA[2022-07-28]]></title><description><![CDATA[r7kamura's working log on 2022-07-28]]></description><link>https://r7kamura.github.io/diary/articles/84</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/84</guid><pubDate>Wed, 27 Jul 2022 22:40:03 GMT</pubDate><content:encoded><![CDATA[<hr><p>rubocop gemを改造して、slimファイルを直接動作させる実験に成功した。</p>
<pre><code>$ ./exe/rubocop dummy.slim
Inspecting 1 file
W

Offenses:

dummy.slim:1:3: C: [Correctable] Style/FrozenStringLiteralComment: Missing frozen string literal comment.
- "a"
  ^
dummy.slim:1:3: C: [Correctable] Style/StringLiterals: Prefer single-quoted strings when you don't need string interpolation or special symbols.
- "a"
  ^^^
dummy.slim:1:6: C: [Correctable] Layout/TrailingEmptyLines: Final newline missing.
- "a"
     
dummy.slim:2:3: C: [Correctable] Style/FrozenStringLiteralComment: Missing frozen string literal comment.
= b
  ^
dummy.slim:2:4: C: [Correctable] Layout/TrailingEmptyLines: Final newline missing.
= b
   
dummy.slim:3:5: C: [Correctable] Style/FrozenStringLiteralComment: Missing frozen string literal comment.
| #{"c"}
    ^
dummy.slim:3:5: C: [Correctable] Style/StringLiterals: Prefer single-quoted strings when you don't need string interpolation or special symbols.
| #{"c"}
    ^^^
dummy.slim:3:8: C: [Correctable] Layout/TrailingEmptyLines: Final newline missing.
| #{"c"}
       
dummy.slim:4:3: W: Lint/UselessAssignment: Useless assignment to variable - a.
- a = 1
  ^
dummy.slim:4:3: C: [Correctable] Style/FrozenStringLiteralComment: Missing frozen string literal comment.
- a = 1
  ^
dummy.slim:4:8: C: [Correctable] Layout/TrailingEmptyLines: Final newline missing.
- a = 1
       
dummy.slim:5:3: C: [Correctable] Style/FrozenStringLiteralComment: Missing frozen string literal comment.
- a if array.size > 0
  ^
dummy.slim:5:8: C: [Correctable] Style/NumericPredicate: Use array.size.positive? instead of array.size > 0.
- a if array.size > 0
       ^^^^^^^^^^^^^^
dummy.slim:5:8: C: [Correctable] Style/ZeroLengthPredicate: Use !empty? instead of size > 0.
- a if array.size > 0
       ^^^^^^^^^^^^^^
dummy.slim:5:22: C: [Correctable] Layout/TrailingEmptyLines: Final newline missing.
- a if array.size > 0
                     
dummy.slim:6:3: C: [Correctable] Style/FrozenStringLiteralComment: Missing frozen string literal comment.
- a if !b
  ^
dummy.slim:6:3: C: [Correctable] Style/NegatedIf: Favor unless over if for negative conditions.
- a if !b
  ^^^^^^^
dummy.slim:6:10: C: [Correctable] Layout/TrailingEmptyLines: Final newline missing.
- a if !b
         
dummy.slim:7:3: C: [Correctable] Style/FrozenStringLiteralComment: Missing frozen string literal comment.
- a if !b # rubocop:disable Style/NegatedIf
  ^
dummy.slim:7:44: C: [Correctable] Layout/TrailingEmptyLines: Final newline missing.
- a if !b # rubocop:disable Style/NegatedIf
                                           
dummy.slim:8:6: C: [Correctable] Style/FrozenStringLiteralComment: Missing frozen string literal comment.
- if "a"
     ^
dummy.slim:8:6: C: [Correctable] Style/StringLiterals: Prefer single-quoted strings when you don't need string interpolation or special symbols.
- if "a"
     ^^^
dummy.slim:8:9: C: [Correctable] Layout/TrailingEmptyLines: Final newline missing.
- if "a"
        

1 file inspected, 23 offenses detected, 22 offenses autocorrectable
</code></pre><hr><p>rubocopの改造とrubocop-slimでの実験が上手くいったので、rubocopにpull requestをdraftで出した。</p>]]></content:encoded></item><item><title><![CDATA[2022-07-27]]></title><description><![CDATA[r7kamura's working log on 2022-07-27]]></description><link>https://r7kamura.github.io/diary/articles/83</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/83</guid><pubDate>Tue, 26 Jul 2022 22:38:02 GMT</pubDate><content:encoded><![CDATA[<hr><p>githubのcommand palleteが進化していて、pull requestのtitleやdescriptionを変更するコマンドが増えているのを発見した。UIも個別のページごとに最適化されるようになっていた。ドキュメントページを見に行ったらその説明も追加されているようだった。</p>
<p>descriptionのeditボタンを押すためにchrome extenisonをつくっていたけれど、このコマンドがあればお役御免かもしれない。</p><hr><p>.rubocop_todo_corrector_ignore というファイルを置けるように機能追加した。</p><hr><p>1Passwordのアプデをしたら大きめにUIが変わって、そしてone-time passwordをcopyするためのショートカットキーが動かないようだった。これは公式フォーラムにサインアップして不具合報告をしておいた。結構使う機能なのでこれが動かないのは苦しい。</p><hr><p>Google Homeとルンバの連携を試した。両方のアプリをiPhoneに入れていたので非常に短い手順で完了できた。3タップぐらい。</p>
<p>音声操作は、「N時間後にルンバを起動して」といった相対時間指定での命令ができるのが便利。</p><hr><p>rubocop-todo-correctorにinputs.gh_create_arguments的なオプションを追加したい。
かなりghべったりな形式になるが、レビュアーやプロジェクトや追加のラベルの割当などを柔軟にできるようになる。</p><hr><p>BUNDLE_ONLYが使えるようになる変更がMergeされた。bundler 2.4.0には入るはず。</p><hr><p>Performance/RedundantMatch copのautocorrectに漏れがあったので改善した。</p><hr><p>workflow dispatchのAPI周りに不具合がありそうだったのでdiscussionで報告した。</p>
<ul>
<li><a href="https://togithub.com/community/community/discussions/27262">https://togithub.com/community/community/discussions/27262</a></li>
</ul><hr><p>RuboCopの内部実装にPull Requestを出すべくコードを読んでいる。</p>
<p>RuboCop::Team#investigate(processed_source) が、ファイルを受け取ってOffensesを返すという実装を担っているから、この辺にRubyExtractorを噛ませられるような変更をできないか検討しているところ。</p><hr><p>RuboCop::Runner#do_inspection_loop あたりでやるほうが丸いかもしれない。ここがfileからprocessed_sourceに変換している箇所であるので、ここがfileからprocessed_sourcesに変換するように変わったとしても違和感ない。</p><hr><ol>
<li>一通りCopに掛ける</li>
<li>不要な <code>rubocop:disable</code> を検知するために1回掛ける</li>
<li>不要な <code>rubocop:enable</code> を検知するために1回掛ける</li>
</ol>
<p>というのが1つのファイルに対して行われることらしい。この2, 3の再実行処理のために、sourceが再利用されているっぽい。</p>
<p>do_inspection_loopはprocesed_sourceを引数に取るようにして、もうちょい外側でfileからprocessed_sourceに変換するようにすれば上手くいくかも。</p><hr><p>繰り返しの単位が、1つのファイルに対して一通りautocorrectを試して、変更が加わればまたファイルを読み込み直してもう一度、という感じなので、ここより外側でprocessed sourceに分解してると読み込み直しができなくて詰まった。もっと内側でやらないとダメかも。</p>]]></content:encoded></item><item><title><![CDATA[2022-07-26]]></title><description><![CDATA[r7kamura's working log on 2022-07-26]]></description><link>https://r7kamura.github.io/diary/articles/82</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/82</guid><pubDate>Tue, 26 Jul 2022 06:17:05 GMT</pubDate><content:encoded><![CDATA[<hr><p>これを書いた。
<a href="https://dev.to/r7kamura/aggregate-offenses-count-in-rubocoptodoyml-4oda">Aggregate offenses count in .rubocop_todo.yml - DEV Community 👩‍💻👨‍💻</a></p><hr><p>これを書いた。
<a href="https://r7kamura.com/articles/2022-07-26-stray">『Stray』をやった</a></p>]]></content:encoded></item><item><title><![CDATA[2022-07-25]]></title><description><![CDATA[r7kamura's working log on 2022-07-25]]></description><link>https://r7kamura.github.io/diary/articles/81</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/81</guid><pubDate>Sun, 24 Jul 2022 21:22:54 GMT</pubDate><content:encoded><![CDATA[<hr><p>昨日に引き続き、vscode-rubyのlanguage-server-rubyを読んでいく。</p>
<p>昨日は6つのProviderから構成されているという話をし、DocumentHighlightProviderの実装を読んだ。</p>
<ul>
<li>FoldingRangeProvider</li>
<li>DocumentHighlightProvider</li>
<li>DocumentSymbolProvider</li>
<li>DocumentFormattingProvider</li>
<li>ConfigurationProvider</li>
<li>WorkspaceProvider</li>
</ul><hr><p>SelectionRangeProviderというのを追加すれば、括弧だけでなく二重引用符やdo-endなどにもExpand selectionコマンドを対応させられるはず。</p>
<ul>
<li><a href="https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_selectionRange">https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_selectionRange</a></li>
</ul><hr><p>DocumentSymbolProviderを見てみたが、DocumentHighlightProviderと比べて幾らか難しい実装だった。
tree-sitterのwrapper?であるForestのstreamっぽいAPIを使っていて複雑。</p><hr><p>DocumentHighlightAnalyzerはリクエストのたびにインスタンスをつくって解析する仕組みだったが、DocumentSymbolAnalyzerとFoldingRangeAnalyzerは1個だけつくって使い回す実装らしく、Analyzer.tsがシングルトンをつくってそのプロパティにもたせている。</p><hr><p>Analyzer.tsには深さ優先探索のtree-walkingを行う仕組みが実装されている。treeが送られ続けてくるforestStreamというやつをanalyzerのシングルトンが購読しており、これをwalkで歩き続けつつ、symbolとfoldingの解析を続けている。FoldingRangeリクエストを受け取った際には、このanalyzerのシングルトンの現在の状態を読んで返すだけ。</p><hr><p>DocumentFormattingProviderを見てみよう。</p>
<p>次の二種類のリクエストに対応するProviderであるらしい。</p>
<ul>
<li>textDocument.Formatting</li>
<li>textDocument.rangeFormatting</li>
</ul>
<p>前者は与えられたドキュメント全体を、後者は与えられたドキュメントのうち指定された範囲のフォーマットを整えるためのものらしい。</p>
<blockquote>
<p>The document range formatting request is sent from the client to the server to format a given range in a document</p>
</blockquote>
<p>language-server-rubyの実装では、ここでRuboCopやらRufoやらを利用することになる。</p>
<p>rxjsのObservableが利用されている。外部のプロセスとのやりとりが発生するところをこれでやりとりしているのだろうか。</p>
<p>「ドキュメント」という単位が何を表しているのかという話があった。これは多分「ファイル」と読み替えてもさほど影響はないように思う。language-server-rubyでは、DocumentManager.tsがdocumentsというシングルトンを提供している。ドキュメントはIDを持っているらしく、このIDでdocumentsに問い合わせると対象のドキュメントが取得できるという仕組みらしい。</p>
<p>vscode-languageserverというパッケージがdocumentsを管理する仕組みを提供していて、documents.listen(connection) とやると良い感じにクライアントのドキュメントの情報を管理してくれるらしい。つまり、document formattingのリクエストでわざわざソースコードをやり取りしなくても、そこではドキュメントのIDだけ含めておけば良くなるということ。</p>
<p>Formatting Providerは、リクエストに応じて <code>Promise&#x3C;TextEdit[]></code> を返せば良いらしい。TextEditはvscode-languageserverが提供している。TextEditというのは、テキストを変形させる命令のことだと思う (e.g. replaceとか)。</p>
<blockquote>
<p>result: <a href="https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textEdit">TextEdit[]</a> | null describing the modification to the document to be formatted.</p>
</blockquote>
<p>BaseFormatterとRuboCopFormatterを見てみると、spawnを使って子プロセスをつくり、そこで <code>bundle exec rubocop -s ... -a</code> を実行していることがわかる。-sは標準入力経由で使うやつらしい。</p>
<pre><code>    -s, --stdin FILE                 Pipe source from STDIN, using FILE in offense
                                     reports. This is useful for editor integration.
</code></pre>
<pre><code>$ echo "1 + 2" | rubocop -s foo.rb -A
Inspecting 1 file
C

Offenses:

foo.rb:1:1: C: [Corrected] Style/FrozenStringLiteralComment: Missing frozen string literal comment.
1 + 2
^
foo.rb:2:1: C: [Corrected] Layout/EmptyLineAfterMagicComment: Add an empty line after magic comments.
1 + 2
^

1 file inspected, 2 offenses detected, 2 offenses corrected
====================
# frozen_string_literal: true

1 + 2
</code></pre>
<p>これで ====== の後ろを見れば変更後のコードが取得できる。この標準出力をもとに、``TextEdit[]` を用意する。これには<a href="https://github.com/google/diff-match-patch">diff-match-patch</a>というNPMパッケージが利用されている。</p>
<p>選択範囲だけformatしてくれというリクエストだった場合でも、ファイル全体に対してRuboCopを利用するが、diffを見て選択範囲からの書き換えだけ適用することになっている。</p><hr><p>LSPの説明でmethod, paramsと呼ばれていたのはこういうやつのことか。</p>
<blockquote>
<p>LSP クライアントからサーバーへのメッセージとして、以下のような文字列が送られます。(改行は \r\n)</p>
</blockquote>
<pre><code>Content-Length: 88

{
    "jsonrpc": "2.0",
    "id": 1,
    "method": "shutdown",
    "params": null
}
</code></pre>
<ul>
<li><a href="https://qiita.com/vain0x/items/d050fe7c8b342ed2004e#_reference-a5e1c1658f719e7db952">https://qiita.com/vain0x/items/d050fe7c8b342ed2004e#_reference-a5e1c1658f719e7db952</a></li>
</ul>
<blockquote>
<p>この文字列は、今回はサーバーのプロセスの標準入力に送られてきます。標準入力を受け取るには process.stdin の data イベントを監視して、送られてくるデータをバッファーにためていけばいいです。</p>
</blockquote>
<p>実際にはどう送られてくるのかと思ったら、この場合は標準入力を利用しているんだな。素朴で嬉しい。</p><hr><p>vscode-textlintが要件としては分かりやすくて参考になりそうだった。実装はまだ読んでいない。</p>
<ul>
<li><a href="https://github.com/taichi/vscode-textlint">https://github.com/taichi/vscode-textlint</a></li>
</ul><hr><p>クライアント側の実装も学び始めた。これを読んでみている。</p>
<ul>
<li><a href="https://qiita.com/minebreaker/items/c53e4dddb0709492d362">https://qiita.com/minebreaker/items/c53e4dddb0709492d362</a></li>
</ul>
<p>クライアント (vscodeの拡張) 起動時に、サーバ起動用のコマンド名も記述するもんなんだな。まあそれはそうか。
例えばsolargraph gemはlanguage serverを提供していたはずで、あれは別途自前で起動させておくものだった気がするから、多分そういう場合にはサーバーを起動しないオプションもあるのだと思う。</p><hr><p>手元でvscode-rubyのビルドを試してみたが大変だった。これを見ながら進めた。</p>
<ul>
<li><a href="https://github.com/rubyide/vscode-ruby/blob/main/docs/developing.md">https://github.com/rubyide/vscode-ruby/blob/main/docs/developing.md</a></li>
</ul>
<pre><code>yarn install
</code></pre>
<p>これを実行する時点でエラー。./packages/vscode-ruby-client/package.jsonからdependenciesに書いているlanguage-server-rubyが存在しないとのこと。lernaの使い方が間違ってるとか? とりあえずこのdependenciesの行を手動で消すと進めるように。</p>
<p>yarn install中にtree-sitter-rubyの何かでエラー。npm install tre-sitter-rubyを試すも問題無し。再度yarn installを実行するとなぜか成功。なぜ？</p>
<p>yarn watchも失敗。</p>
<blockquote>
<p>Error: error:0308010C:digital envelope routines::unsupported
at new Hash (node:internal/crypto/hash:67:19)</p>
</blockquote>
<p>webpackのhash関数がどうのこうのということで、ググってこの環境変数を追加して再試行すると上手くいった。</p>
<pre><code>export NODE_OPTIONS=--openssl-legacy-provider
</code></pre>]]></content:encoded></item><item><title><![CDATA[2022-07-24]]></title><description><![CDATA[r7kamura's working log on 2022-07-24]]></description><link>https://r7kamura.github.io/diary/articles/80</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/80</guid><pubDate>Sat, 23 Jul 2022 21:18:27 GMT</pubDate><content:encoded><![CDATA[<p>今回はvscode-rubyの読書メモを書き連ねていきます。</p><hr><p>vscode-rubyは、複数のパッケージを扱うmonorepoとして管理されている。</p>
<ul>
<li>vscode-ruby</li>
<li>vscode-ruby-client</li>
<li>vscode-ruby-debugger</li>
<li>language-server-ruby</li>
</ul>
<p>monorepoの管理にはLernaを使っているとのこと。</p><hr><p>language-server-rubyについて詳しく見ていく。</p>
<p>package.jsonを見ると、次のパッケージがdependenciesに含まれていた。</p>
<ul>
<li>web-tree-sitter</li>
<li>web-tree-sitter-ruby</li>
</ul>
<p>web- prefix付きなのが気になるが、確かにtree-sitterが使われている。</p>
<p>package.jsonのmainフィールドにdist/index.jsとあり、npm run buildではesbuild.jsが利用されている。</p>
<p>esbuild.jsの中では、web-tree-sitter-ruby/tree-sitter-ruby.wasmが参照されている。
なるほど、WASM形式でビルドされてNode.js等で使えるように配布されているのがweb-tree-sitterなのかな。
ちなみにtree-sitterはRustで実装されている。</p><hr><ul>
<li><a href="https://github.com/rubyide/vscode-ruby">https://github.com/rubyide/vscode-ruby</a></li>
<li><a href="https://github.com/tree-sitter/tree-sitter">https://github.com/tree-sitter/tree-sitter</a></li>
<li><a href="https://github.com/tree-sitter/tree-sitter-ruby">https://github.com/tree-sitter/tree-sitter-ruby</a></li>
</ul><hr><p>language-server-rubyのesbuild.jsを見ると、次の二つのことをやっているのが分かる。</p>
<ul>
<li>tree-sitter{,-ruby}.wasmをコピーして、distディレクトリに入れる</li>
<li>src/inedx.tsをビルドして、distディレクトリに入れる</li>
</ul>
<p>language-server-rubyのエントリポイントがsrc/index.jsであることが分かったので、ここを読み進めていく。</p><hr><p>手元に環境にnodenvが入っているので、vscode-rubyのリポジトリのルートディレクトリで次のコマンドを実行するだけで環境構築を完了させられた。</p>
<pre><code>nodenv install
npm install
</code></pre>
<p>これをやらないと、VSCodeが怒ってくる。</p>
<p><img src="https://user-images.githubusercontent.com/111689/180624816-964a6b5b-a25a-44e5-bc95-26d8ea1b648f.png" alt="image"></p><hr><p>esbuildを使うのは初めてだけど、こういう感じで使うんだなあ。</p>
<p><code>esbuild</code> というexecutableを実行するわけではなく、</p>
<pre><code>node esbuild.js
</code></pre>
<p>と実行するというのが面白い。普通だったらオプションとかを渡したくなってCLIオプションを付けるためにCLIを用意するものだけど、esbuildの場合はどうせ設定ファイルを用意することになるので、そういうものを用意する必要は無いわという判断なのだろうか。まあ無くて良いなら無いに越したことはない。</p><hr><pre><code class="language-javascript">// Don't die when attempting to pipe stdin to a bad spawn
// https://github.com/electron/electron/issues/13254
process.on('SIGPIPE', () => {
	log.error('SIGPIPE received');
});
</code></pre>
<p>とあり、そういえばVS CodeはElectronベースだから、Electronの不具合の影響を受けるんだったと思い出した。</p><hr><p>基本のlanguage serverの実装はこういう感じのようだ。</p>
<pre><code class="language-javascript">import { createConnection, ProposedFeatures } from "vscode-languageserver";
cosnt connection = createConnection(ProposedFeatures.all);
// Customize connection as you like...
connection.listen();
</code></pre><hr><pre><code class="language-javascript">let server;
connection.onInitialize(async (params) => {
  server = new Server(connection, params);
  server.initialize();
  return server.capabilities;
});
</code></pre>
<p>こんな感じのコードが書かれているから、実際には <code>Server</code> という内部実装の中でいろいろな処理をやっている。</p>
<p>なので、読むべきは次の実装:</p>
<ul>
<li>Serverのconstructor</li>
<li>Server#initialize</li>
</ul>
<p>capabilitiesというのは、「このlanguage serevrはDocumentHighlightに対応ています」のような情報を明示するためのオブジェクトらしい。</p>
<ul>
<li><a href="https://code.visualstudio.com/api/language-extensions/programmatic-language-features">https://code.visualstudio.com/api/language-extensions/programmatic-language-features</a></li>
</ul><hr><p>language-server-rubyでは、VS Codeの拡張として提供する各機能の単位を "Provider" と呼称しているようだ。VS Codeの用語なのか独自用語なのかはわからない。</p>
<p>language-server-rubyでは、次の6つのProviderを用意しているようだ。</p>
<ul>
<li>FoldingRangeProvider</li>
<li>DocumentHighlightProvider</li>
<li>DocumentSymbolProvider</li>
<li>DocumentFormattingProvider</li>
<li>ConfigurationProvider</li>
<li>WorkspaceProvider</li>
</ul>
<p>前者4つは初期化フェーズ中に用意され、後者2つは初期化フェーズ完了後に用意される。connection.onInitializeとconnection.onInitialize<strong>d</strong>でそれぞれ用意されている。</p>
<ul>
<li>Server#initialize</li>
<li>Server#setup</li>
</ul>
<p>でそれぞれ実装されているが、このネーミングは少し分かりづらい…</p>
<ul>
<li>Server#onConnectionInitialize</li>
<li>Server#onConnectionInitialized</li>
</ul>
<p>とかで良かっただろうと思う。</p>
<p>その話はさておき、Server.tsの主な仕事はこのようにProviderを用意してあげることらしく、主な実装はつまりそれぞれのProviderに書かれているに違いない。</p>
<p>Providerは、初期化時にconnectionを受け取って、何か良い感じに動くもののようだということが分かっている。</p><hr><p>各種Providerは基底Providerクラスを継承しているらしい。
各種Providerは .registerというstatic methodを持っていて、外部向けのインターフェースがこれ</p><hr><p>Connection#onDocumentHighlight という、コールバック登録用のメソッドが生えているらしいDocumentHighlightProviderはこれをそのconstructorで呼び出している。ググってもonDocumentHighlightに関する情報は乏しい……</p>
<p>onDocumentHighlightに渡す引数はServerRequestHandler型で、実際のコード例を見ると、TextDocumentPositionParams型の引数を取るらしい。位置情報が与えられるので、それに応じて何か適切に動作しろということだろうか。<code>Promise&#x3C;DocumentHighlight[]></code> 型の値を返す関数として実装されている。</p>
<p>paramsはpositionとuriを持つObjectらしい。多分ファイルパスとその中での位置情報が入っている。</p>
<p>DocumentHighlightAnalyzer.analyze にこれらの値を渡してその返り値をそのまま返している。役割分担を整理するとこうだ:</p>
<ul>
<li>Provider
<ul>
<li>Connection#onDocumentHighlight のことを知っている</li>
<li>適切なハンドラー関数を用意してあげる責務を持つ</li>
</ul>
</li>
<li>Analyzer
<ul>
<li>Connectionについては詳しいことは知らない</li>
<li>コードの位置情報とファイルパスをもらって解析を行うだけ</li>
</ul>
</li>
</ul><hr><p>DocumentHighlightAnalyzerでは、tree-sitterを利用した構文の解析と、<code>DocumentHighlight[]</code> の生成をやっている。どういう機能を持っているかというと、多分こんな感じ:</p>
<ul>
<li>endにカーソルを載せているときは、対応するbeginやdoからendまでをハイライトする</li>
<li>beginやdoにカーソルを載せているときは、そこから対応するendまでをハイライトする</li>
</ul>
<p>tree-sitter-rubyの生成する構文木の実例を見ながら進めていった方が分かりやすいかもしれない。</p>
<p>vscodeの "document highlight" という機能・概念を正確にするため、ぐぐってみた方が良さげ。</p>
<blockquote>
<p>A document highlight is a range inside a text document which deserves special attention. Usually a document highlight is visualized by changing the background color of its range.</p>
</blockquote>
<ul>
<li><a href="https://vshaxe.github.io/vscode-extern/vscode/DocumentHighlight.html">https://vshaxe.github.io/vscode-extern/vscode/DocumentHighlight.html</a></li>
</ul>
<p><img src="https://user-images.githubusercontent.com/111689/180629880-49960fae-d5b1-4e47-8978-4e66791d37bd.png" alt="image"></p>
<p>いろいろ調べていると、次のような言及があった。</p>
<blockquote>
<p>textDocument/documentHighlightは、同じシンボルの使用箇所をエディタ上でハイライトする場合にも使用できます。</p>
</blockquote>
<ul>
<li><a href="https://qiita.com/atsushieno/items/ce31df9bd88e98eec5c4">https://qiita.com/atsushieno/items/ce31df9bd88e98eec5c4</a></li>
</ul>
<p><img src="https://user-images.githubusercontent.com/111689/180630105-73de7a93-c83b-4004-abda-4a95db868978.png" alt="image"></p><hr><p><img src="https://user-images.githubusercontent.com/111689/180648140-a095e438-519d-43c1-9028-7b29296b3fa0.png" alt="image"></p>
<p>この機能だな。endにカーソルが載っている状態だと、そのendと対応するdoの背景色が変わっている。</p>
<p>if elsif else end や case when end, begin rescue else ensure end のときは全部光ってほしいな。少し改良してみる。</p>]]></content:encoded></item><item><title><![CDATA[2022-07-22]]></title><description><![CDATA[r7kamura's working log on 2022-07-22]]></description><link>https://r7kamura.github.io/diary/articles/78</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/78</guid><pubDate>Thu, 21 Jul 2022 21:50:04 GMT</pubDate><content:encoded><![CDATA[<hr><p>editabroにmonaco-markdownを導入するprをもらったので、monaco-markdownのソースコードを一通り読んでいる</p><hr><p>editabroのCIを改善して、リリースノート自動生成機能を有効化し (ノート生成だけまだ実験的なので手動でやっていた)、あと提出用のzipの自動生成とリリースへの紐づけも行うようにした。</p>
<p>どうやらChrome Web Storeへの提出も自動でやってくれるactionがあるらしいが、なんか怖いのと説明文を提出のついでに直したりする工程がいま存在しているので、ここの自動化は未着手。</p><hr><p>r7kamura/workflowsに、chrome拡張のリリース用workflowを足した。</p><hr><p>WindowsでもMagic Trackpadが動いたので最高。</p><hr><p>MV7をしばらく試した感想:</p>
<ul>
<li>ダイナミックマイクを使うと、ほとんどの音が耳元で鳴っているかのように聴こえる</li>
<li>打鍵音をダイナミックでマイクを入れてもあまり心地良くない
<ul>
<li>耳元で打鍵されると鬱陶しいから</li>
</ul>
</li>
<li>ひとり語りの音声だけ撮りたい場合はダイナミックマイクの方が音質が相当いい</li>
</ul>
<p>試していない仮説:</p>
<ul>
<li>コンデンサマイクをゲインを下げて口元で使えばそれでいいのでは説</li>
</ul>]]></content:encoded></item><item><title><![CDATA[2022-07-20]]></title><description><![CDATA[r7kamura's working log on 2022-07-20]]></description><link>https://r7kamura.github.io/diary/articles/76</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/76</guid><pubDate>Tue, 19 Jul 2022 21:07:02 GMT</pubDate><content:encoded><![CDATA[<hr><p><a href="https://www.youtube.com/watch?v=CH0rAOmT938&#x26;ab_channel=r7kamura">作業 with r7kamura #81 - YouTube</a></p><hr><p>gh-pr-releaseをリリースノート生成APIで代替できないか色々実験したものの、上手くいかなかった。</p><hr><p>YouTubeのコメント読み上げおばけというchrome拡張、YouTubeを英語のUIにすると英語で読み上げるんだな……</p><hr><p>rubocop-railsにprを出したが、果たして</p>
<ul>
<li><a href="https://togithub.com/rubocop/rubocop-rails/pull/747">https://togithub.com/rubocop/rubocop-rails/pull/747</a></li>
</ul>]]></content:encoded></item><item><title><![CDATA[2022-07-19]]></title><description><![CDATA[r7kamura's working log on 2022-07-19]]></description><link>https://r7kamura.github.io/diary/articles/75</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/75</guid><pubDate>Mon, 18 Jul 2022 21:02:49 GMT</pubDate><content:encoded><![CDATA[<hr><p><a href="https://www.youtube.com/watch?v=Y-DN_nGx3wk">作業 with r7kamura #80 - YouTube</a></p><hr><p><a href="https://www.youtube.com/watch?v=B5wdRcv-zQA">ASMR Coding: Chrome extension in 20 min (subtitle commentary available) - YouTube</a>
これを公開した。</p>]]></content:encoded></item><item><title><![CDATA[2022-07-18]]></title><description><![CDATA[r7kamura's working log on 2022-07-18]]></description><link>https://r7kamura.github.io/diary/articles/74</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/74</guid><pubDate>Sun, 17 Jul 2022 21:04:22 GMT</pubDate><content:encoded><![CDATA[<hr><p><a href="https://www.youtube.com/watch?v=Jq3aA-WH4Wo">作業 with r7kamura #79 - YouTube</a></p><hr><p>github-label-sync-actionという仕組みをつくって実運用に載せたら\Goodという話を記事にまとめておきたい。</p><hr><p><img src="https://user-images.githubusercontent.com/111689/179433107-b8dc65dc-7919-4dbf-9b94-77d5d454ac23.png" alt="image"></p>
<p><img src="https://user-images.githubusercontent.com/111689/179433173-a7138779-c479-426b-9885-c1378cfda08a.png" alt="image"></p>
<p>ほとんどの人が黒色買ってて、やっぱり黒色の方が見た目がいい気がする。キーボードが黒色だから対比としてグレーの方がいいかなと思ったけど、これ見ると黒色の方が良さそうに見える。この人は机の天板が黒色だから対比となるようグレーにしたと仰っていて、それは納得できる理由。</p>
<p>引用元:</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=rs8RSewaLjQ">https://www.youtube.com/watch?v=rs8RSewaLjQ</a></li>
<li><a href="https://www.youtube.com/watch?v=6VD9kFY4Abk">https://www.youtube.com/watch?v=6VD9kFY4Abk</a></li>
</ul>
<p>Amazon.co.jpで調べた限りだと、やはり高いけど有名なGrovemadeのblack mediumか、日本のメーカーがつくっている4800円のやつが良さそうに思った。Grovemadeは公式で90ドルだけど、12400円+送料 (+関税?) になる。Amazonだと19800円で取り扱っている。いずれもAmazonでは公式で売っているわけではなくて、マーケットプレイス経由。</p>
<p>800円ぐらいのものも売られているが、品質が怪しい、サイズがなぜか適切なやつが無い、到着が数週間後になるなどのものが多い。恐らく中国製ということだろう。</p>
<ul>
<li><a href="https://www.amazon.co.jp/dp/B08X3ZMF41">https://www.amazon.co.jp/dp/B08X3ZMF41</a></li>
<li><a href="https://www.amazon.co.jp/dp/B09VYR9CJM">https://www.amazon.co.jp/dp/B09VYR9CJM</a></li>
</ul><hr><p><img src="https://user-images.githubusercontent.com/111689/179458518-5b555e96-411e-4a9b-bbd1-93881efb3190.png" alt="image">
<img src="https://user-images.githubusercontent.com/111689/179461028-cf4a249d-1995-41ea-8fbe-ff80e3328635.png" alt="image">
<img src="https://user-images.githubusercontent.com/111689/179459179-ce723926-d285-4496-997f-f2a5627e9015.png" alt="image">
<img src="https://user-images.githubusercontent.com/111689/179459914-c37c1c9f-b82c-4808-b49e-f2f3cb7162ff.png" alt="image">
<img src="https://user-images.githubusercontent.com/111689/179460576-389eff26-91ac-4ac2-bb2e-0b61c834293a.png" alt="image"></p>
<p>some compositions</p><hr><p>最終稿</p>
<p><img src="https://user-images.githubusercontent.com/111689/179465665-58e60a56-00a8-49e1-8a92-e97e52afbb27.png" alt="image"></p>]]></content:encoded></item><item><title><![CDATA[2022-07-17]]></title><description><![CDATA[r7kamura's working log on 2022-07-17]]></description><link>https://r7kamura.github.io/diary/articles/73</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/73</guid><pubDate>Sat, 16 Jul 2022 20:59:17 GMT</pubDate><content:encoded><![CDATA[<hr><p><a href="https://www.youtube.com/watch?v=9RB2jKD2Wd8">作業 with r7kamura #78 - YouTube</a></p><hr><p>editabroがchrome web storeで公開された
<a href="https://chrome.google.com/webstore/detail/editabro/eodgdnjgkjjlohklhoaapfhghgcoihmf">https://chrome.google.com/webstore/detail/editabro/eodgdnjgkjjlohklhoaapfhghgcoihmf</a></p><hr><p>GitHubのラベルを予めYAMLで定義したものに同期してくれるActionと、keepachangelogベースで定義したYAMLファイルを置くリポジトリをつくった。
<a href="https://github.com/r7kamura/github-label-sync-action">https://github.com/r7kamura/github-label-sync-action</a></p>
<p>この辺を組み合わせることで、ラベルを一気に用意してPull Requestに付与しておいたらGitHubの機能で良い感じのリリースノートを自動生成できるようになった。</p>]]></content:encoded></item><item><title><![CDATA[2022-07-16]]></title><description><![CDATA[r7kamura's working log on 2022-07-16]]></description><link>https://r7kamura.github.io/diary/articles/72</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/72</guid><pubDate>Fri, 15 Jul 2022 21:11:28 GMT</pubDate><content:encoded><![CDATA[<hr><p><a href="https://www.youtube.com/watch?v=fyUllbOF1sA">作業 with r7kamura #77 - YouTube</a></p><hr><p>viteでchrome拡張をつくるときに</p>
<pre><code>npm run dev
</code></pre>
<p>だとservice workerが読み込めなくて常に失敗するという問題に悩まされていて、ここ一ヶ月色々調べても解決できていなかったのだが、今日遂に</p>
<pre><code>npm run dev -- --port 3001
</code></pre>
<p>のように3000番ポート以外で試すと上手くいくことが分かった。</p>
<p>つまり、3000番だと何かおかしい環境になってしまっているのかも。昔3000番でも普通に動いていた時代はあったので、そのときの情報がChromeに残っていて問題が起きているのかもしれない。</p><hr><p>togithub.com ドメインを代わりに使えばIssueまどのreference linkが生成されなくて良いよという話を教えてもらった。</p>]]></content:encoded></item></channel></rss>