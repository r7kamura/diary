<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[r7kamura/diary]]></title><description><![CDATA[r7kamura's daily working log.]]></description><link>https://r7kamura.github.io/diary/</link><generator>r7kamura/diary</generator><lastBuildDate>Tue, 23 Aug 2022 00:26:51 GMT</lastBuildDate><atom:link href="https://r7kamura.github.io/diary/feed.xml" rel="self" type="application/rss+xml"/><item><title><![CDATA[2022-08-22]]></title><description><![CDATA[r7kamura's working log on 2022-08-22]]></description><link>https://r7kamura.github.io/diary/articles/109</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/109</guid><pubDate>Mon, 22 Aug 2022 00:33:20 GMT</pubDate><content:encoded><![CDATA[<hr><p>vscode-solargraph、たまにdocument highlightが壊れてエラーのポップアップを右下に出し続ける状態になるので、そこは体験が悪い</p><hr><p>型の特定ができるようになってきたので、今度はこれを利用する補完の提案機能をつくってみようと思う</p><hr><p>solargraphはYARDのパース機能を使わず、自前でソースコードをコメントと一緒にパースしながら、自前でYard::CodeObject::Baseのインスタンスを生成し、自前でHashに詰めて管理しているので、こんなに複雑になっているんだなということが分かった。</p>
<p>YARDの機能では拾いきれないもの (ローカル変数などに対する <code>@type</code> タグとか?) があってそのために自前でやっているのかな?</p><hr><p>Symbolの補完</p>
<ul>
<li>シンボルを入力しようとしていそうであれば補完する</li>
<li>そのプロジェクトに存在する全てのSymbol (リテラル?) を返す</li>
<li>Gemに含まれてるものは無視していい?</li>
</ul>
<p>YARD Tagの補完</p>
<ul>
<li>コメント内でかつタグっぽい場所であれば補完する</li>
<li>知っているすべての定数から補完</li>
<li>上手く検索するために検索器がそこそこ優秀なAPIを提供している</li>
</ul><hr><p>Cursorはsourceとpositionを保持するだけのあまり意味のない抽象かと思っていたものの、Cursor#start_of_constant? などを見ると必要そうな抽象かも。補完のコンテキストでよく出てくる。</p><hr><p>Closureというのは、コンテキストを作り得るノード (solargraphにおいてはPin) を表すようで、class, module, def, (block?) などがあるっぽい</p><hr><p>coreとstdlibのyardocを生成しておいて、それを起動時にデフォルトで読み込む、というのをやる必要がありそう。</p>]]></content:encoded></item><item><title><![CDATA[2022-08-21]]></title><description><![CDATA[r7kamura's working log on 2022-08-21]]></description><link>https://r7kamura.github.io/diary/articles/108</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/108</guid><pubDate>Sun, 21 Aug 2022 00:09:53 GMT</pubDate><content:encoded><![CDATA[<hr><p><img src="https://user-images.githubusercontent.com/111689/185770074-846d26d1-51b9-4e4c-aafd-fba5ba3f1d64.png" alt="image"></p>
<p>「カーソルが指しているノードの型が分かる場合はそれを返す」という実装をつくってみようとしている。</p>
<p>ソースコードとカーソル位置を与えると、カーソルの指しているノードと、そのコンテキストを作り出しているノード (ここでは <code>A#b</code>) を返す、という実装を試しにつくった。これはソースコードをパースして位置情報やノードの種類で走査すれば実現できた。</p>
<p>メソッドの仮引数である <code>foo</code> の型注釈はYARDから引いてこれるので、これらを結び付ければ導出できるはず。</p><hr><p>メソッド内の</p>
<ul>
<li>ローカル変数</li>
<li>レシーバーの無いメソッド呼び出し</li>
</ul>
<p>について、それぞれYARDで型注釈が与えられていないか調べにいって、あればそれを返すという実装ができた。</p>
<p><img src="https://user-images.githubusercontent.com/111689/185775606-714f6a39-2505-478f-bc2f-a7d712d97f37.png" alt="image"></p><hr><p>メソッドチェーンに再帰的に対応できた。</p>
<p>あとは対応するノードの種類を増やしていけば、YARDの注釈ベースで型を推測するという機能は完成しそう。</p><hr><p>次回対応したいもの</p>
<ul>
<li>local variable assignment</li>
<li>constant</li>
<li>singleton method</li>
</ul>]]></content:encoded></item><item><title><![CDATA[2022-08-20]]></title><description><![CDATA[r7kamura's working log on 2022-08-20]]></description><link>https://r7kamura.github.io/diary/articles/107</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/107</guid><pubDate>Fri, 19 Aug 2022 22:02:19 GMT</pubDate><content:encoded><![CDATA[<hr><p>Solargraphのソースコードを大体読みたいところを読み終わった。</p>
<ul>
<li>当初は、自前で似たものをつくってより深く学んでみようと考えていた</li>
<li>Solargraphのやっていることの規模が大きすぎて、自分で実装するには大変そうだった</li>
<li>仕組みは大体予想通り。やっていそうなことをやっていた</li>
<li>yard gemsがビルドしたファイルからデータを読み込んで集約し、それをMarshal.dumpでキャッシュしていた</li>
<li>Libraray, ApiMap, Pin, SourceMap, YardMap, Host</li>
<li>Inferの仕組みもやるべきことを淡々とやっている感じであった</li>
</ul>]]></content:encoded></item><item><title><![CDATA[2022-08-19]]></title><description><![CDATA[r7kamura's working log on 2022-08-19]]></description><link>https://r7kamura.github.io/diary/articles/106</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/106</guid><pubDate>Thu, 18 Aug 2022 21:31:56 GMT</pubDate><content:encoded><![CDATA[<hr><p>引き続きSolargraph</p><hr><h3>workspace</h3>
<p>プロジェクトのディレクトリに対して1つのWorkspaceが割り当てられる。</p>
<h3>library</h3>
<ul>
<li>1つのlibraryが1つのApiMapを持つ</li>
<li>1つのソースコードと対応している?
<ul>
<li>現在見ているソースコードという状態を持っているだけで、そうではないかも</li>
</ul>
</li>
<li>1つのworkspaceが複数のlibraryを持つ?
<ul>
<li>library belongs_to workspace という関係</li>
</ul>
</li>
<li>要請に応じて違反や定義元を返したりする役割も持っている</li>
</ul><hr><ol>
<li>エディタ起動時、エディタのworkspaceが <code>Host#prepare_folders</code> で読み込まれる</li>
<li>Solargraph::Library.loadでそのディレクトリの情報が用意される</li>
<li>Host#librariesに読み込んだ情報が登録される</li>
<li>エディタからのリクエストに応じて、Host#librariesが検索される</li>
</ol><hr><p>Library#find_external_requires という実装があった。そのソースコード内の <code>require</code> を集めているらしい。</p>
<p>bundlerの管理するgemのYARDはどう読み込まれているのか気になって調べてみた。
YardMapでrequire_from_bundleというのがあったので、Gemのソースは多分ここで読み込まれている。YardMapがどこから使われているかは不明。ApiMapがYardMapの参照を持っているので多分ApiMapが管理している。yard_mapは、definitionを調べるリクエストとtype checkから使われていた。</p><hr><p>Workspace#generate_require_paths を見ていると、gemspecが存在する場合は、それを読んでrequire_pathsの内容からどのファイルを読むべきか推測するというコードが書かれていた。デフォルトではlibになる。</p><hr><p>Workspace#initializeではそのディレクトリの配下のRubyのソースコードがほぼ全て読み込まれ、Solargraph::Sourceに変換される。</p><hr><p>Solargraphで定数をgo to definitionしたときには候補が沢山表示されるなと思っていたが、これはRubyがオープンクラスできるためで、その定数をnamespaceとして利用している実装が候補に上がるためである。solargraphは第一候補として一番それらしいやつを挙げてくれるようなので、大体のケースではF12を二回押すだけで事足りる。</p><hr><p>カーソル位置についての処理を担当するのがClipクラスらしい。</p><hr><p>ApiMapというのは、いろんなところでソースコードの集合を扱うための実装で、1つのLibraryが1つのApiMapを持っていたり…するらしいが概念がよく分からない...がlibraryが複数のソースコードを扱う存在であると考えるなら妥当かも。</p><hr><p>ApiMapが大きいやつで、SourceMapが小さいやつ…</p><hr><p>最初のステップとして、<code>@param</code> で仮引数の型が明示されている場合に、その仮引数の定義位置を返す、という機能を実装できるようにしてみるのはどうか。</p><hr><ol start="0">
<li>Solargraph::LanguageServer::Message::TextDocument::Definition 型を表すPinの配列からLSP用の位置情報を返す</li>
<li>Host#definitions_at</li>
<li>Library#definitions_at</li>
<li>Clip#define カーソル位置のチェーン (一連のまとまり) から推測される型を表すPinの配列を返す</li>
<li>Chain#define ほぼ同上</li>
<li>Chain#infer_first_defined 型の計算が行われる中核部分</li>
<li>Link#resolve 型を表すPinの配列を返す</li>
</ol>
<p>chain.linksのlinksはchainの要素で、a.b.cの場合linksはa, b, cみたいな感じ。</p>
<p>ApiMapをchainあたりまで引き回しているが、これはdatabase connectionみたいなもので、実際のソースコードの情報を色々引いてくるにはこうするのが妥当。</p>
<p>inferが結構大変そう。
例えば、メソッドの本体部分からreturn valueになり得るものを探してそのnodeの取り得る型をinferするとか。
infer無しでYARDの型定義だけ探して無ければ諦めるならまだマシそう。</p><hr><p>どこかで library.catalog が呼ばれて、そのタイミングで libarary.api_map の内容が更新される (ソースコードが読み込まれる?) と思うんだけど、いつどこで呼ばれるのか分かっていない。</p>
<p>CLIから呼ばれるときはそこで呼ばれてるんだけど、Language Serverから呼ばれるときは… Host#catalog で呼ばれていた。あとスレッドを立てて、0.01秒sleepしながら一生catalogを呼び出し続けていた。DidChangeWatchedFiles命令でも呼び出している。起動時にも呼び出していると思うのだが…これはその別スレッドが呼び出すのだろう。</p>]]></content:encoded></item><item><title><![CDATA[2022-08-18]]></title><description><![CDATA[r7kamura's working log on 2022-08-18]]></description><link>https://r7kamura.github.io/diary/articles/105</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/105</guid><pubDate>Wed, 17 Aug 2022 21:33:05 GMT</pubDate><content:encoded><![CDATA[<hr><p>solargraph gemのソースコードを読んでいく。</p><hr><p>vscodeの方はほぼ何もしておらず、コマンドをサーバーに送信しているだけだった。</p>
<ul>
<li><a href="https://github.com/castwide/solargraph">https://github.com/castwide/solargraph</a></li>
<li><a href="https://github.com/castwide/vscode-solargraph">https://github.com/castwide/vscode-solargraph</a></li>
</ul><hr><p>solargraphの方では、Host#prepare(directory)でHost#librariesにSolargraph::Librariesを溜めておき、Host#diagnoseでこれに問い合わせている。</p><hr><p>Host#diagnoseの実装はLibrary#diagnoseに委譲されていた。更に、Diagnostics::Reporter.reporter(name)に委譲されている。</p><hr><p>Diagnostics::Rubocopに辿り着いた。これはReporterの1つで、他にはTypeCheckなどがあるらしい。</p><hr><p>lib/solargraph/diagnostics/rubocop.rb を見た。vscode-ruby-lightとやっていることはほぼ同じだった。</p><hr><p>Diagnosticsを読むのは終えて、Documentというのを読んでみることに。これはHost#document -> Library#document -> ApiMap#document と委譲されている。</p><hr><p>vscode-ruby-lightのおかげで手軽にRubyのソースコードのシンボル情報を得られるようになって、メソッド名で検索するというのがやりやすくなって捗るようになった。</p><hr><p><code>api_map.clip(cursor).complete</code> でその地点の補完候補を返しているようなので、これを読んでみる。</p><hr><p>インライン化すると <code>SourceMap::Clip.new(self, cursor).complete</code> になる。</p><hr><pre><code class="language-ruby"># @return [Completion]
def complete
  return package_completions([]) if !source_map.source.parsed? || cursor.string?
  return package_completions(api_map.get_symbols) if cursor.chain.literal? &#x26;&#x26; cursor.chain.links.last.word == '&#x3C;Symbol>'
  return Completion.new([], cursor.range) if cursor.chain.literal?
  if cursor.comment?
    tag_complete
  else
    code_complete
  end
end
</code></pre><hr><p>cursor.chainで使われているChainは、メソッドチェーンなどの一連のトークン列を表すやつ? トークン、と読み替えても差し支えない気がする。chain.linksはtoken.previous_tokens。</p>
<p>そうなると、</p>
<pre><code class="language-ruby">  return package_completions(api_map.get_symbols) if cursor.chain.literal? &#x26;&#x26; cursor.chain.links.last.word == '&#x3C;Symbol>'
</code></pre>
<p>これは、現在カーソルがSymbolリテラルを指しているときは、Symbol一覧の補完候補を出しましょうということになる。libraryに問い合わせていて、libraryは1つのファイルについての情報のみを持っているはずだから、これは「現在ファイル内のSymbolから補完候補を出す」ということになりそう。</p>
<p>ところで、単純なワードだけを補完するのであれば、VSCodeの標準機能がそれを補完候補に含めてくれるはずなので、実際これは意味があるんだろうか...? 補完候補の優先順位が上がるとかだろうか。</p><hr><pre><code>solargraph socket --host 0.0.0.0
</code></pre>
<p>とやることでWSL環境でもsolargraphが動いた。これをしないと動かない……デフォルトだと127.0.0.1になってこれがWSLだと動かない (別のもの...Windows側のホスト?に解決される?) のだと推測している。</p>
<p><img src="https://user-images.githubusercontent.com/111689/185257843-4fc4893a-5096-4183-98b8-fd7353042181.png" alt="image"></p>
<p>引数にhoverするとツールチップが表示されて、リンクっぽい文字列をクリックするとwebviewというやつが開くことが確認できた。webviewを使ってドキュメント表示を実現しているらしい。ドキュメントの計算には時間が掛かるから、1ステップ踏ませている、という努力が見られる気がする。</p><hr><p>stdioモードにしたら上手く動いた。</p><hr><p>vscode-solargraphを見ると、stdioモードの場合は起動時にクライアント側でsolargraph stdioをspawnしている様子が見て取れた。extentionKindがworkspaceなので、当然クライアント側で起動してもOK。</p><hr><p>typecheckerは面白いけど、YARD viewerみたいなものがあればそれで十分かなあ。</p>
<pre><code class="language-ruby"># @params [Foo::Bar] bar
</code></pre>
<p>に対して、Rubyで <code>Foo::Bar</code> の定義元を調べたりメソッドの情報を調べたりできるともっと便利だけど、これは実行してみないといけないので、適切にrequireしたりする必要があって色々大変かも。</p><hr><p>vscode-ruby-lightにYARD Viewer機能をつくってみてもいいかも。できるところまでシグネチャを解析して、ビルドされたYARDのデータベースに一致すればその情報を返すというもの。</p>
<p>あとデフォルトで標準ライブラリについての情報は持っておいてもいいかも。そうなるとYARDに限らない気もするけど。</p><hr><p>もうしばらくsolargraphのコードを読んでいく。</p>
<p>Pin, SourceMap, ApiMap辺りの概念を把握する必要がありそう。</p><hr><p>コード上のオブジェクトのことをPinと呼ぶようだ。例えば、一つの派生形として、Pin::Methodがある。</p>]]></content:encoded></item><item><title><![CDATA[2022-08-17]]></title><description><![CDATA[r7kamura's working log on 2022-08-17]]></description><link>https://r7kamura.github.io/diary/articles/104</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/104</guid><pubDate>Tue, 16 Aug 2022 21:06:14 GMT</pubDate><content:encoded><![CDATA[<hr><p>Style/FormatStringTokenは、特定のメソッドの引数やレシーバーのときのみ動作するようにしても良いんじゃないかと思った。それから、autocorrectできそうなコンテキストでしない場合があるので、これは直したいかも。</p><hr><p>vscode-ruby-lightにYARDサポートを入れてもいいかもしれない。
yard gemsとyriを使ってみたら何かできそうな気がした</p>
<ul>
<li><a href="https://github.com/lsegal/yard">https://github.com/lsegal/yard</a></li>
</ul><hr><p>solargraphのソースコードを読んでみることにする。</p>]]></content:encoded></item><item><title><![CDATA[2022-08-16]]></title><description><![CDATA[r7kamura's working log on 2022-08-16]]></description><link>https://r7kamura.github.io/diary/articles/103</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/103</guid><pubDate>Tue, 16 Aug 2022 00:27:22 GMT</pubDate><content:encoded><![CDATA[<hr><p><a href="https://r7kamura.com/articles/2022-08-16-vscode-ruby-light">Ruby用VSCode拡張: vscode-ruby-light</a>を書いた。</p>]]></content:encoded></item><item><title><![CDATA[2022-08-15]]></title><description><![CDATA[r7kamura's working log on 2022-08-15]]></description><link>https://r7kamura.github.io/diary/articles/102</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/102</guid><pubDate>Mon, 15 Aug 2022 01:48:52 GMT</pubDate><content:encoded><![CDATA[<hr><p>vscode-ruby-lightのrubocopの機能を使うにはDocker越しではいけないので、devcontainerで開発てしみる実験を始めた。</p>
<p>何故か普通にセットアップして起動しようとすると起動できないのだが、別途 docker-compose up -d rails と起動してやるとrialsサービスにattachしながらVSCodeが起動できるという状態。これは自前でやることなしに上手くできてほしい…… vscodeの実行するコマンドでrailsサービスが適切に指定されてほしい気がする。</p><hr><p>ともあれ上手くいった。</p>
<p>自分で入れたghコマンドのauthを通すにはどうしたらいいか考えていたのだけど、ホスト側から ~/.config/gh/hosts.yml をマウントしてあげるのが良さそうだった。これはリポジトリには入れられないので、docker-compose.override.yml のvolumesの設定に書いてattachしてもらうしかないかも。</p>
<ul>
<li><a href="https://github.com/cli/cli/discussions/3226">https://github.com/cli/cli/discussions/3226</a></li>
</ul><hr><p>services.rails.depends_onに指定されているやつをrunServicesに指定したら上手く動いた。これ指定しないといけないのかあ。</p>
<pre><code class="language-json">{
  "name": "Rails",
  "dockerComposeFile": [
    "../docker-compose.yml"
  ],
  "service": "rails",
  "runServices": [
    "elasticsearch",
    "mysql",
    "redis"
  ],
  "workspaceFolder": "/workspace"
}
</code></pre><hr><p>docker-compose.override.yml はわざわざ指定しなくてもちゃんと読み込んでくれるっぽい。単純にVSCodeもdocker-composeコマンドを実行しているだけなので当たり前ではあるか。</p><hr><pre><code class="language-json">{
  "name": "Rails",
  "dockerComposeFile": [
    "../docker-compose.yml"
  ],
  "service": "rails",
  "runServices": [
    "rails"
  ],
  "workspaceFolder": "/workspace"
}
</code></pre>
<p>こう書いてもいけそうだ。</p><hr><p>一度VSCodeのworkspaceを閉じて再度開いてReopen containerするだけではdotfilesは再インストールしてくれないみたいだ。</p><hr><p>Git 2.22の機能を使っていたが、Git 2.20が入っていて面倒だったので、それに対応する.bashrcに差し替えたという経緯。</p>
<pre><code>cd /root/dotfiles
git pull
cd -
source ~/.bashrc
</code></pre>
<p>で解決させた。</p><hr><p>ssh-agentが動いていないのでgit pushなどがhang outする問題のことを忘れていてまた遭遇した。が対処方法を覚えていたので、keychainを使って勝手にssh-agentが起動するようにした。</p>]]></content:encoded></item><item><title><![CDATA[2022-08-14]]></title><description><![CDATA[r7kamura's working log on 2022-08-14]]></description><link>https://r7kamura.github.io/diary/articles/101</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/101</guid><pubDate>Sat, 13 Aug 2022 21:01:51 GMT</pubDate><content:encoded><![CDATA[<hr><p>よく見たら昨日で作業ログも100回になっていた。昨日の配信が105回目だったから、配信6日目から作業ログを書き始めたらしい。</p><hr><p>RuboCopを使えるようにした。</p>
<ul>
<li><a href="https://github.com/r7kamura/vscode-ruby-light">https://github.com/r7kamura/vscode-ruby-light</a></li>
</ul>
<p>これあるならRailsの開発ではdocker-compose通して開発するよりdevcontainer使った方がこの機能使えて便利だな</p>]]></content:encoded></item><item><title><![CDATA[2022-08-13]]></title><description><![CDATA[r7kamura's working log on 2022-08-13]]></description><link>https://r7kamura.github.io/diary/articles/100</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/100</guid><pubDate>Sat, 13 Aug 2022 02:55:05 GMT</pubDate><content:encoded><![CDATA[<hr><p><img src="https://user-images.githubusercontent.com/111689/184465817-ffd84eb9-2e0c-4f90-ac8c-4dc1b344009d.png" alt="image"></p><hr><p>Node.jsのspawnを使ってrubocopを動かして結果をvscodeでdiagnosticsとして表示する実験に成功した。</p><hr><p>BGMの音量が小さい気がしたので、-6.9dBにした。まあSpotify側でも音量下げてるのであれなんだけど、自分が聞いている音量と比較して-6.9dBということになる。</p><hr><p>RuboCopにrangeを指定してautocorrectしてもらう機能を提供してもらいたい。最悪loopしなくても単発でそのCopだけ適用してもらえればまあ良いと思う…でも実際それだと使い物にならないかもしれない。</p>]]></content:encoded></item><item><title><![CDATA[2022-08-12]]></title><description><![CDATA[r7kamura's working log on 2022-08-12]]></description><link>https://r7kamura.github.io/diary/articles/99</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/99</guid><pubDate>Fri, 12 Aug 2022 00:07:43 GMT</pubDate><content:encoded><![CDATA[<hr><p>Windowsで使っているMagic Trackpad 3をAmazon WorkSpacesで繋いだWindowsの上で動かそうとするとどうなるのか心配だったけど、特に問題無さそうだった。ポインタ移動イベントみたいなのを送っているだけで、実際には接続先にドライバが入っているかどうかなどは関係が無さそうに見える</p><hr><p><img src="https://user-images.githubusercontent.com/111689/184274107-5c793a8d-e537-4cbb-82ac-93b45afb4da2.png" alt="image"></p>
<p>デフォルトのRuby用Grammerが % の処理でハイライトにミスってる例を見つけた。</p>]]></content:encoded></item><item><title><![CDATA[2022-08-11]]></title><description><![CDATA[r7kamura's working log on 2022-08-11]]></description><link>https://r7kamura.github.io/diary/articles/98</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/98</guid><pubDate>Wed, 10 Aug 2022 21:49:40 GMT</pubDate><content:encoded><![CDATA[<hr><p>rubocopのtemplate supportのためのドキュメントを書いている</p><hr><p>WindowsでRuboCopを試すためにgit-for-windowsとruby installerを実行している</p><hr><p>Windowsで試してみたらテストが失敗し、追加したテストコードにCR+LFの問題があることがわかった。</p><hr><p>rubocopのtemplate supportのpull requestを改善して、ドキュメントを豊富にして落ちていたwindowsでのテストも修正した。</p><hr><p>rubocopってasciidocでドキュメント書かれているんだなあ。markdown wrapperというイメージだけど、主にどういう利点でasciidocにしているんだろう</p><hr><p>例えば、コメント中で改行したときに適切に次の行の先頭にコメント用文字列を挿入するという処理は一体どう実現しているのか。調べてみると、例えばvscode-rustでは次のように実装されているようだった。</p>
<ul>
<li><a href="https://github.com/rust-lang/vscode-rust/pull/156/files">https://github.com/rust-lang/vscode-rust/pull/156/files</a></li>
</ul>
<p>VSCode ExtensionがonEnterという専用の仕組みを提供していて、前の行に対して正規表現を指定することで、そういうことができるらしい。</p>
<p>Rubyの <code>class A</code> などを入力したあとのインデント処理も同じ仕組みで実現されているのだろうか。</p><hr><p>シンタックスハイライトは完璧ではないけれど、とはいえここはそこまでコーディング中に困っている箇所でもないので、formatterやdiagnosticsの機能を優先したほうが良い気がしてきた。</p>]]></content:encoded></item><item><title><![CDATA[2022-08-10]]></title><description><![CDATA[r7kamura's working log on 2022-08-10]]></description><link>https://r7kamura.github.io/diary/articles/97</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/97</guid><pubDate>Tue, 09 Aug 2022 22:29:52 GMT</pubDate><content:encoded><![CDATA[<hr><p>書いた</p>
<ul>
<li><a href="https://dev.to/r7kamura/bundleonly-is-now-available-2bb7">BUNDLE_ONLY is now available - DEV Community 👩‍💻👨‍💻</a></li>
</ul><hr><p>今日もSemantic Tokensの実装を少し進めてみた。Semantic Tokensで実装できると大変嬉しいのだが、やはり下地として誤ったGrammerがあると、Semantic Tokensで塗りつぶそうとしても結局正しく扱うことができない。</p>
<p>他の作戦として、Grammerを空っぽに塗りつぶしつつSemantic Tokensを使う方法もあるが……</p><hr><ul>
<li><a href="https://github.com/microsoft/vscode/blob/main/extensions/theme-defaults/themes/dark_plus.json">https://github.com/microsoft/vscode/blob/main/extensions/theme-defaults/themes/dark_plus.json</a></li>
</ul><hr><p>grammerが空でも動く程度のSemantic Tokensの完全実装を目指してみることにした。膨大な種類のトークンに対応する必要があるが……</p>]]></content:encoded></item><item><title><![CDATA[2022-08-09]]></title><description><![CDATA[r7kamura's working log on 2022-08-09]]></description><link>https://r7kamura.github.io/diary/articles/96</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/96</guid><pubDate>Mon, 08 Aug 2022 21:10:01 GMT</pubDate><content:encoded><![CDATA[<hr><p>RuboCopに出しているPull Requestのうち2件がどちらもこちらの作業待ちなので、早く取り掛からないといけない。どちらもドキュメントを追加するという仕事が残っているので大変。</p><hr><p>シンタックスハイライトの実装方法について悩んでいる。</p>
<p>TextMateの文法ファイルを拡張側で管理して正規表現でやっていくか、あるいはLSPのSemantic Tokensを使ってtree-sitterで解析した結果に対してアプローチするか。</p><hr><p>Semantic Tokensで幾らか実装してみた。</p>
<ul>
<li>真面目にやろうとすると既存のTextMateの文法ファイルがやっているのとほぼ同等の機能を自分で実装することになる</li>
<li>tree-sitter-parserが使えるとはいえ、別にそこまで楽にはならない</li>
<li>既存のシンタックスハイライトを部分的に上書きするということがなかなか難しい</li>
<li>大事なのは良いscopeのセットを提供することで、TextMateの文法ファイルはここにもたいへんな功績がある</li>
<li>tree-sitter-parserがやってくれるのは、TextMateの文法ファイルの正規表現の部分の実装だけ
<ul>
<li>個々のトークンに名前を割り当ててscopeも割り当てる、というのを逐一やっていく必要がある</li>
</ul>
</li>
</ul><hr><p>forkしたTextMate文法を改善していくのが良さそうということになった。しかし大変そうではある……</p><hr><p>Semantic Tokensだと設定で無効化できるけど、Grammerだと無効化するには拡張ごと無効化するしかない。</p><hr><p>よく見たら bunder のBUNDLE_ONLYオプションリリースされてた。</p>
<ul>
<li><a href="https://github.com/rubygems/rubygems/blob/master/bundler/CHANGELOG.md">https://github.com/rubygems/rubygems/blob/master/bundler/CHANGELOG.md</a></li>
</ul>]]></content:encoded></item><item><title><![CDATA[2022-08-08]]></title><description><![CDATA[r7kamura's working log on 2022-08-08]]></description><link>https://r7kamura.github.io/diary/articles/95</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/95</guid><pubDate>Sun, 07 Aug 2022 21:09:29 GMT</pubDate><content:encoded><![CDATA[<hr><p>OBSのブラウザソースでXMLHttpRequest使ってローカルファイル読み込めるよって話。</p>
<ul>
<li><a href="https://obsproject.com/forum/threads/obs-cannot-access-local-files-from-local-html-javascript.128171/">https://obsproject.com/forum/threads/obs-cannot-access-local-files-from-local-html-javascript.128171/</a></li>
</ul>
<p>fetchだとセキュリティの問題があって難しいっぽい? OBS起動時のオプション引数で云々みたいな話もあるので、これ次第では行ける可能性もある。それと、XMLHttpRequestの例もこの引数が前提となっている可能性もある。</p><hr><p>例えばSpotifyで再生中の楽曲名を表示したい場合に、Snipというアプリを使うとテキストファイルに楽曲名を書き出してくれる。普通はテキストソースを利用してこれを表示することになるが、上の方法を使えばJavaScriptからでも読み出せるので、もっとリッチな表現をしたい場合に使えそう。</p><hr><p><img src="https://user-images.githubusercontent.com/111689/183312908-833e1fd6-5029-4bca-ac32-29071c0174b0.png" alt="image"></p>
<p>DocumentSymbolに対応すべく、とりあえず全部の名前付きノードをSymbolとして登録してみる実験を行った。</p><hr><p><img src="https://user-images.githubusercontent.com/111689/183316030-51ebf9ea-47c2-4d6c-9179-641ac9f4a549.png" alt="image"></p><hr><p><img src="https://user-images.githubusercontent.com/111689/183356245-393cc4d8-c61d-4980-89b0-681db3b3cd97.png" alt="image"></p>
<p>OBS Studio 0.28 beta + Spotify + SnipでNow playingを表示することに成功。</p><hr><p>SemanticTokensに対応しようとしているが、これまでと若干インターフェースが違っていて難しい。</p><hr><p><a href="https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_semanticTokens">https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_semanticTokens</a></p><hr><p>YouTubeのr7kamura channelの再生リストを整理して、</p>
<ul>
<li>Pomodoro I</li>
<li>Pomodoro II</li>
</ul>
<p>の2つに分けた。前者にはここまで100回分が入っていて、明日からは新シーズンとして後者を始めるという感じ。</p>
<p>タイトルも、"Work with r7kamura" からより実態と即していそうな "Pomodoro with me" に変えることに。タイトルの <code>#100</code> はタグ判定されてしまうことがわかったので、記号は外すことにした。</p>
<ul>
<li><a href="https://www.youtube.com/c/r7kamura">https://www.youtube.com/c/r7kamura</a></li>
</ul><hr><p>Semantic Tokensに関するチュートリアル情報を見つけた</p>
<ul>
<li><a href="https://code.visualstudio.com/api/language-extensions/semantic-highlight-guide">https://code.visualstudio.com/api/language-extensions/semantic-highlight-guide</a></li>
</ul><hr><p>公式のサンプル集にもあった。まずここを探すべきだった:</p>
<ul>
<li><a href="https://github.com/microsoft/vscode-extension-samples/tree/main/semantic-tokens-sample">https://github.com/microsoft/vscode-extension-samples/tree/main/semantic-tokens-sample</a></li>
</ul>]]></content:encoded></item><item><title><![CDATA[2022-08-07]]></title><description><![CDATA[r7kamura's working log on 2022-08-07]]></description><link>https://r7kamura.github.io/diary/articles/94</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/94</guid><pubDate>Sun, 07 Aug 2022 06:58:15 GMT</pubDate><content:encoded><![CDATA[<hr><p><a href="https://github.com/r7kamura/vscode-ruby-light">r7kamura/vscode-ruby-light: Lightweight VSCode extension for Ruby.</a></p><hr><p>market placeに登録する方法を調べたい。</p><hr><p><a href="https://code.visualstudio.com/api/working-with-extensions/publishing-extension">Publishing Extensions | Visual Studio Code Extension API</a></p><hr><p>Registered to Azure DevOps, using r7kamura GitHub account, then created an organization there.</p>
<p><img src="https://user-images.githubusercontent.com/111689/183279423-6f33bf4a-e2a5-4cb8-b392-0a1cdc2e8f73.png" alt="image"></p><hr><blockquote>
<p>Image URLs in README.md and CHANGELOG.md need to resolve to https URLs.</p>
</blockquote>
<p>現状READMEに相対パスでGIFのURLを記載しているので、これが描画されない可能性がありそう。</p><hr><p>と思いきやそのままで上手く表示されていた。</p>
<ul>
<li><a href="https://marketplace.visualstudio.com/items?itemName=r7kamura.vscode-ruby-light">https://marketplace.visualstudio.com/items?itemName=r7kamura.vscode-ruby-light</a></li>
</ul>
<pre><code>npx vsce login
npx vsce publish
</code></pre>
<p>上のコマンドを入力するだけで公開された。</p>
<p>loginではpersonal access tokenを聞かれた。これはArure DevOpsの上で作成した上のリンクの手順に従い、All accessible organizationかつMakreplace Manage scopeかつ90 daysのexpiration daysで作成した。90 daysにしたのは、select boxで選択できる中でそれが最長だったため。</p>
<p>publishするとURLが発行され、最初は404だったが、3分ほどで公開されてアクセスできるようになった。</p><hr><p>しかしマーケットプレイスのものからインストールしてみると動かない。手元でビルドしてインストールしてみると動く。</p><hr><p>マーケットプレイスのものをマニュアル・ダウンロードして入れると動く……</p><hr><p>普通に?インストールすると上手く動くが、Install Locallyを押すと動かないということが分かりつつある。</p><hr><p>extensionKindがuiでHost側にインストールされると動かないみたいだった。うーむ。手元でvsixをつくってWindows側でインストールしてみるともっと情報が得られるかもしれない。</p>
<p>workspaceにしたら動いたので、v0.1.1をpublishした。</p><hr><p><a href="https://marketplace.visualstudio.com/items?itemName=r7kamura.vscode-ruby-light">Ruby Light - Visual Studio Marketplace</a></p><hr><p><a href="https://github.com/r7kamura/vscode-ruby-light">https://github.com/r7kamura/vscode-ruby-light</a></p>]]></content:encoded></item><item><title><![CDATA[2022-08-06]]></title><description><![CDATA[r7kamura's working log on 2022-08-06]]></description><link>https://r7kamura.github.io/diary/articles/93</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/93</guid><pubDate>Fri, 05 Aug 2022 21:23:11 GMT</pubDate><content:encoded><![CDATA[<hr><p><img src="https://user-images.githubusercontent.com/111689/183218594-34042320-c476-44c8-8de9-e7d47f9d0c28.png" alt="image"></p>
<p>if-elseif-else-endをHighlightする作業を進めている</p><hr><p><img src="https://user-images.githubusercontent.com/111689/183224573-7adea94a-7740-47c2-8c60-84235d3219c1.gif" alt="1"></p><hr><p><img src="https://user-images.githubusercontent.com/111689/183226158-fd6a65ee-6062-45d2-8d44-d96dc068872e.png" alt="image"></p>
<p>子供みたいなコードになった</p><hr><p><img src="https://user-images.githubusercontent.com/111689/183244677-ca6e409e-ca4f-4724-aa4b-10654e3a3d06.gif" alt="1"></p>]]></content:encoded></item><item><title><![CDATA[2022-08-05]]></title><description><![CDATA[r7kamura's working log on 2022-08-05]]></description><link>https://r7kamura.github.io/diary/articles/92</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/92</guid><pubDate>Thu, 04 Aug 2022 21:03:13 GMT</pubDate><content:encoded><![CDATA[<hr><p>空いた時間にVSCodeのRuby用拡張を進捗させたい。</p><hr><p><code>Promise&#x3C;T></code> の代わりに <code>Thenable&#x3C;T></code> と記載している例をVSCodeのコード例でよく見るが、これはjQuery.Deferredなど他の各種Promise系のやつでも受け入れるための型クラスらしい。</p><hr><p>DocumentSelector</p>
<p>その拡張がどういうドキュメント (VSCodeがタブとかで開くテキストの単位) で有効になるかを絞り込むための条件を指定する単位。次の2つの情報を持てるらしい</p>
<ul>
<li>どのファイルタイプか
<ul>
<li>e.g. <code>ruby</code></li>
</ul>
</li>
<li>どのschemeか
<ul>
<li>e.g. <code>file</code>, <code>untitled</code></li>
<li>現実的にはファイルが永続化されているかどうか (適当に新規タブで開いたやつはuntitled) を判別するのに使われることがほとんどっぽい?</li>
</ul>
</li>
</ul>
<p><a href="https://code.visualstudio.com/api/references/document-selector">https://code.visualstudio.com/api/references/document-selector</a></p>
<p>Example from lsp-example:</p>
<pre><code class="language-js">[
  { scheme: "file", language: "plaintext" }
]
</code></pre>
<p>Example from vscode-ruby-client:</p>
<pre><code class="language-js">[
  { scheme: "file", language: "ruby" },
  { scheme: "untitled", language: "ruby" },
]
</code></pre><hr><p>vscode packageのこれをClientOptionsに指定したものの、詳しく調べていない。</p>
<pre><code>workspace.createFileSystemWatcher
</code></pre><hr><p>vscode-ruby-clientだと、clientOptionsのmiddleware.workspaceを指定している。これはmulti workspaceのための何かだろうか。</p><hr><p>default import/export おさらいのコーナー。</p>
<pre><code class="language-typescript">import * as path from "path";
</code></pre>
<p>例えば、上のコードを下のコードのように書き換えてみる。</p>
<pre><code class="language-typescript">import path from "path";
</code></pre>
<p>すると、次のようなエラーが確認できる。</p>
<pre><code>Module '"path"' can only be default-imported using the 'esModuleInterop' flagts(1259)
path.d.ts(167, 5): This module is declared with using 'export =', and can only be used with a default import when using the 'esModuleInterop' flag.
</code></pre>
<p>これは、JavaScriptにおける幾つかのモジュールシステムのdefault import/exportに関する挙動が異なることが原因で……</p>
<p>TypeScriptは何も設定していない場合、ES6風のモジュールシステムを前提に動くので、</p>
<pre><code class="language-typescript">import a from "b"
</code></pre>
<p>に対しては、</p>
<pre><code class="language-typescript">const a = require("b").default
</code></pre>
<p>のようなコードを生成し、</p>
<pre><code class="language-typescript">import * as a from "b"
</code></pre>
<p>に対しては、</p>
<pre><code class="language-typescript">const a = require("b")
</code></pre>
<p>のようなコードを生成する。</p>
<p>path moduleは export default してはおらず普通に export しているので、後者の方法を使う必要があるという話。</p>
<p>このTypeScriptの挙動は</p>
<pre><code class="language-json">{ "esModuleInterop": true }
</code></pre>
<p>のように設定すると変えることもできる。</p><hr><p>lsp-exampleは、トップレベルのパッケージがVSCode extensionとして配布される形になっている。</p>
<p>というのも、次のようにサーバープロセスを起動するためのパスが記載されているので、拡張のルートディレクトリから見て ./server/out/server.js というのがあることが分かる。</p>
<pre><code class="language-typescript">const serverModule = context.asAbsolutePath(
	path.join("server", "out", "server.js")
);
</code></pre><hr><p>vscode-ruby-clientが次のようになっているので</p>
<pre><code class="language-typescript">client = new LanguageClient('ruby', 'Ruby', serverOptions, clientOptions);
client.registerProposedFeatures();
</code></pre>
<p>registerProposedFeaturesの定義を見に行った。現在は空の配列が返ってくるだけだが、過去には</p>
<pre><code class="language-typescript">[
  new pd.DiagnosticFeature(client),
  new nb.NotebookDocumentSyncFeature(client)
]
</code></pre>
<p>のような配列が返ることもあったらしい。要はβ版の新機能を取り込むための処理だろうか。</p><hr><p>vscode-ruby-client/srcを見るとlinterやらcompletionやらが転がっているが、これは過去にクライアント側で正規表現を用いて機能が実装されていた頃の名残で、現在はどうやら参照されていないように見える。</p><hr><p>つまりクライアント側はほぼ何も実装しなくても良い感じっぽい。</p><hr><p>lsp-exampleのサーバー側の実装を少しずつ読んでいる。</p>
<ul>
<li>onInitializeで、clientのcapabilitiesを見ながらserverのcapabilitiesを返す</li>
<li>onInitializedで、必要な初期化処理をやっていく。connection.listenとか</li>
</ul>
<p>この拡張の機能に関するデフォルトの設定があり、これが各テキストドキュメントごとのデフォルトの設定になる。テキストドキュメント単位で設定値を上書きすることが可能なので、こうなっている。テキストドキュメントのURIをIDとして、Mapオブジェクトを利用して設定値のキャッシュを持っている。</p>
<p>設定値はクライアントが保持していて、サーバーがそれを知るには connection.workspace.getConfigurationで問い合わせる必要がある。この問い合わせ結果を上述のキャッシュに保存しておいているという仕組み。既に問い合わせ済みであればそのキャッシュから取得する。設定値変更イベントがクライアントで発生した場合、それがconnection経由で伝わってくるので、その場合サーバーはキャッシュを全部消す。これにより、次回の設定値取得時には新たにクライアントから取得しにいくようになるという寸法。</p>
<p>テキストドキュメントが閉じられる際には、キャッシュからも設定値を消す。現在開かれているテキストドキュメントの設定値しか保持しないことで、サイズを小さく抑えるため?</p>
<p>設定が変更された場合は、diagnosticsの検査をいちからやり直す。設定値の変化により検査結果が変わることがあるため。</p><hr><p>試しにhighlight機能を追加してみる。</p>
<p>まずonInitializeで返すcapabilitiesにプロパティを追加して、documentHighlightProviderに対応していることを示す。</p>
<pre><code class="language-diff">diff --git a/server/src/server.ts b/server/src/server.ts
index 8e1ddf8..5b83ad7 100644
--- a/server/src/server.ts
+++ b/server/src/server.ts
@@ -54,6 +54,7 @@ connection.onInitialize((params: InitializeParams) => {
       completionProvider: {
         resolveProvider: true,
       },
+      documentHighlightProvider: true,
     },
   };
   if (hasWorkspaceFolderCapability) {
</code></pre><hr><p>Provider.register(connection) を呼び出すタイミングとして、onInitializeとonInitializedの2パターンがあるけれど、どのProviderではどのタイミングを選べばいいのだろうか。</p>
<p>vscode-rubyでは、DocumentHighlightProviderはonInitializeで登録しているようだ。</p><hr><p><a href="https://github.com/microsoft/vscode-extension-samples">https://github.com/microsoft/vscode-extension-samples</a> にはdocumentHighlightProvider: trueとしている例は見当たらなかったので、実装例が無い。とりあえずvscode-rubyのやっている方法に従ってみることにする?</p><hr><p><img src="https://user-images.githubusercontent.com/111689/182980343-1afaca7e-b566-46ea-94c5-f5bbe2d4bc35.png" alt="image"></p>
<p>カーソルを合わせるとconnection.onDocumentHighlightで登録したコールバックが実行されることが無事確認できた。</p>
<p>Language Serverで出しているconsole.logは、Extension Development HostのOutputでセレクトボックスから「Ruby」を選ぶことで表示できた。これは……Clientで指定したnameが使われているっぽい?</p><hr><p><img src="https://user-images.githubusercontent.com/111689/182989897-e98a17c1-3854-40cd-880f-69919b5f9ac7.gif" alt="1"></p>
<p>自前実装で, endに対してDocumentHighlightが動くようになった。</p><hr><p>until, for, while についても対応しようとしたら親子関係というか木の構造が違うらしいことが分かった。それから、moduleもAもどちらもtypeはmoduleであるということも分かり、判定が大変そう。本当にキーワードかどうかはtoStringすれば判定できる。</p>]]></content:encoded></item><item><title><![CDATA[2022-08-04]]></title><description><![CDATA[r7kamura's working log on 2022-08-04]]></description><link>https://r7kamura.github.io/diary/articles/91</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/91</guid><pubDate>Wed, 03 Aug 2022 21:03:38 GMT</pubDate><content:encoded><![CDATA[<hr><p>ゼノブレイド3、かなりよく出来ている。1と2やる必要は全くない。</p>
<p>ムービーが長いという意見を聞いていたが、そこまで長過ぎるようには感じなかった。ここ数年でどんどん人類の嗜好形態が変化していて、長いムービーに耐えられなくなってきているというのはあると思う。</p>
<p>ちょっとHUDがうるさい感じはあるけど、ある程度は消すこともできるし、まあ許容範囲ではある。</p><hr><p><a href="https://dev.to/r7kamura/run-yard-as-rspec-3hnn">Run YARD as RSpec - DEV Community 👩‍💻👨‍💻</a>
これを書いた</p><hr><p><a href="https://github.com/r7kamura/yardspec">https://github.com/r7kamura/yardspec</a>
これを書いた</p>]]></content:encoded></item></channel></rss>