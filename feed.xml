<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[r7kamura/diary]]></title><description><![CDATA[r7kamura's daily working log.]]></description><link>https://r7kamura.github.io/diary/</link><generator>r7kamura/diary</generator><lastBuildDate>Fri, 02 Sep 2022 21:47:58 GMT</lastBuildDate><atom:link href="https://r7kamura.github.io/diary/feed.xml" rel="self" type="application/rss+xml"/><item><title><![CDATA[2022-09-02]]></title><description><![CDATA[r7kamura's working log on 2022-09-02]]></description><link>https://r7kamura.github.io/diary/articles/120</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/120</guid><pubDate>Thu, 01 Sep 2022 23:24:55 GMT</pubDate><content:encoded/></item><item><title><![CDATA[2022-09-01]]></title><description><![CDATA[r7kamura's working log on 2022-09-02]]></description><link>https://r7kamura.github.io/diary/articles/119</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/119</guid><pubDate>Thu, 01 Sep 2022 23:24:12 GMT</pubDate><content:encoded><![CDATA[<hr><p>Clean Craftsmanshipを読み始めた。いまは17%ぐらい。</p>]]></content:encoded></item><item><title><![CDATA[2022-08-31]]></title><description><![CDATA[r7kamura's working log on 2022-08-31]]></description><link>https://r7kamura.github.io/diary/articles/118</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/118</guid><pubDate>Tue, 30 Aug 2022 21:49:03 GMT</pubDate><content:encoded><![CDATA[<hr><p>寝ている間にきていた分のOSSのレビューにはすべて対応し終えた。</p>]]></content:encoded></item><item><title><![CDATA[2022-08-30]]></title><description><![CDATA[r7kamura's working log on 2022-08-30]]></description><link>https://r7kamura.github.io/diary/articles/117</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/117</guid><pubDate>Mon, 29 Aug 2022 21:10:32 GMT</pubDate><content:encoded><![CDATA[<hr><p>20件の動画のタイトルと再生リストを修正するにあたり、YouTube APIを使うか迷った結果、手作業でやることにした。</p>]]></content:encoded></item><item><title><![CDATA[2022-08-29]]></title><description><![CDATA[r7kamura's working log on 2022-08-29]]></description><link>https://r7kamura.github.io/diary/articles/116</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/116</guid><pubDate>Mon, 29 Aug 2022 03:00:15 GMT</pubDate><content:encoded><![CDATA[<hr><p>YouTube APIを使って2つの再生リストをmergeすることにした。</p>]]></content:encoded></item><item><title><![CDATA[2022-08-28]]></title><description><![CDATA[r7kamura's working log on 2022-08-28]]></description><link>https://r7kamura.github.io/diary/articles/115</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/115</guid><pubDate>Sat, 27 Aug 2022 22:33:47 GMT</pubDate><content:encoded><![CDATA[<hr><p>定数の補完に取り組んでいる。</p><hr><p><img src="https://user-images.githubusercontent.com/111689/187054811-124130a3-64c8-4d6d-ab1b-930f01352470.png" alt="image"></p>
<p>実装の隣にテストが書いているの、下手なテキストが書かれているよりよほど分かりやすいような気がする</p>]]></content:encoded></item><item><title><![CDATA[2022-08-27]]></title><description><![CDATA[r7kamura's working log on 2022-08-27]]></description><link>https://r7kamura.github.io/diary/articles/114</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/114</guid><pubDate>Fri, 26 Aug 2022 22:36:05 GMT</pubDate><content:encoded><![CDATA[<hr><p>RubyのコアはRDocでドキュメントが記載されているが、型情報についてはここには記載されないようだった。つまり公式のRDocからデータを読み取って利用する作戦は失敗。</p>
<p>RBSだと型情報が取れる上に公式のRDocから抽出したコメントも併記されているので、代わりにRBSの情報を使うのが良さそうに見える。</p><hr><p>ruby/rubyのRDocではなくruby/rbsのRBSの情報を元にするように変更できた。</p>
<p>YARDと型の表現方法が違ったりする部分の吸収については頑張らないといけない。</p>
<pre><code># RBS
::Array[::String]

# YARD
Array&#x3C;String>
::Array&#x3C;::String> も可
</code></pre><hr><pre><code class="language-ruby">def foo
  bar.
end
</code></pre>
<p>のような書きかけのコードに対して、一時的に情報を補完してパースした上で解析を試みる、という実験が上手くいった。これで補完候補を出せるようになった。このような事情を考えると、エラーに対して問題を最低限の形に押し留めて修復可能なパーサーの登場が望まれる。</p>]]></content:encoded></item><item><title><![CDATA[2022-08-26]]></title><description><![CDATA[r7kamura's working log on 2022-08-26]]></description><link>https://r7kamura.github.io/diary/articles/113</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/113</guid><pubDate>Fri, 26 Aug 2022 07:50:22 GMT</pubDate><content:encoded><![CDATA[<hr><p>型システムの改善を行い、AST中のノードから色々な情報を簡単に取得できるようにした。</p>
<p><img src="https://user-images.githubusercontent.com/111689/186851471-85d08fba-bd47-4d9f-ad63-15e363b9104e.png" alt="image"></p>
<p>いまの課題は、カーソル位置に対して適切な補完候補を出すというもの。単純にパースしようとするとSyntaxErrorになるので、SyntaxErrorになった場合、ならなかった場合とで条件分岐して、なった場合の処理を考える必要がある。ならなかった場合の処理は簡単。</p><hr><p>システムが扱う範囲が型の分野を超えていて、コード解析機という感じになってきた。</p>]]></content:encoded></item><item><title><![CDATA[2022-08-25]]></title><description><![CDATA[r7kamura's working log on 2022-08-25]]></description><link>https://r7kamura.github.io/diary/articles/112</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/112</guid><pubDate>Wed, 24 Aug 2022 21:03:43 GMT</pubDate><content:encoded><![CDATA[<hr><p><img src="https://user-images.githubusercontent.com/111689/186552075-0d7059d6-4a2c-4df1-90a9-4c34cecddc34.png" alt="image"></p>
<p>往年のアスキーアートっぽい</p><hr><p><img src="https://user-images.githubusercontent.com/111689/186552121-12495059-40a3-46a5-9a6e-30e16a321bc1.png" alt="image"></p>
<p>Ruby本体のソースコードから定義を読み取る実験が上手く成功した。</p>]]></content:encoded></item><item><title><![CDATA[2022-08-24]]></title><description><![CDATA[r7kamura's working log on 2022-08-24]]></description><link>https://r7kamura.github.io/diary/articles/111</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/111</guid><pubDate>Tue, 23 Aug 2022 22:20:16 GMT</pubDate><content:encoded><![CDATA[<hr><p>RDocを使ってRubyのソースコードをパースし、定義を記した適当なオブジェクトを得る実験に成功した。</p>
<p>これをYARD::CodeObjects::Baseに変換して取り回すか、あるいはRDocとYARDの両方を束ねるオブジェクトに変換するか、いずれかの方法を取らねばならない。</p><hr><p>RBS等、他のドキュメント形式にも今後対応する必要が出てくるかもしれないので、arts側で仕様を定めたオブジェクトをつくり、それにまとめていくという方がまともだと考えている。</p>]]></content:encoded></item><item><title><![CDATA[2022-08-23]]></title><description><![CDATA[r7kamura's working log on 2022-08-23]]></description><link>https://r7kamura.github.io/diary/articles/110</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/110</guid><pubDate>Tue, 23 Aug 2022 00:25:36 GMT</pubDate><content:encoded><![CDATA[<hr><p>Ruby core &#x26; stdlibのyardocをそれぞれ生成して読み込むことに生成したが、そこには <code>@return</code> みたいなタグが書かれているわけではないので、返り値が計算できない。</p><hr><p>YARDがRubyのコア機能に対して生成するドキュメントには返り値の情報が含まれていないから、てっきり元々書かれていないのかと思いきや、RDocから生成されているはずの <a href="https://docs.ruby-lang.org/en/3.1/Integer.html#method-i-chr">https://docs.ruby-lang.org/en/3.1/Integer.html#method-i-chr</a> を見てみると、情報があるように見える。変換に対応していないだけか?...と思いきや、YARDにlib/yard/parser/c/comment_parser.rbというのがあって、<code>-> true or false</code> をBooleanに変換するロジックなどを持っていた。</p><hr><p>C由来の情報はYARD::Registry.allで取得しようとすると一部欠落する?</p><hr><p>C由来のコメントはoverload tagとして表現されていて、tag.tags(:overload).first.tags(:return) とかやると出てくるみたいだった。</p><hr><p>Ruby 3.1でRubyのソースコードのRDocのcall-sequenceの書き方に変更があったみたいで、YARD::Parser::C::CommentParserが上手くパースできず、何も情報を抽出できない状態となっていた。Ruby 3.0まではレシーバー無しで記述していたのが、Ruby 3.1からはレシーバー付きで記述するようになり、こうなった模様。</p>
<p>上手くやるには、RDocのパーサーを使ってYARDの情報を生成する、という風に書き換えないといけなさそう。あるいはRuby 3.0以下のソースコードからドキュメントを生成する。本当にRuby 3.0ですべてが上手くパースできるのかは怪しいので、RDocのパーサーを使えないか検討することにも依然として価値があるとは思う。</p>]]></content:encoded></item><item><title><![CDATA[2022-08-22]]></title><description><![CDATA[r7kamura's working log on 2022-08-22]]></description><link>https://r7kamura.github.io/diary/articles/109</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/109</guid><pubDate>Mon, 22 Aug 2022 00:33:20 GMT</pubDate><content:encoded><![CDATA[<hr><p>vscode-solargraph、たまにdocument highlightが壊れてエラーのポップアップを右下に出し続ける状態になるので、そこは体験が悪い</p><hr><p>型の特定ができるようになってきたので、今度はこれを利用する補完の提案機能をつくってみようと思う</p><hr><p>solargraphはYARDのパース機能を使わず、自前でソースコードをコメントと一緒にパースしながら、自前でYard::CodeObject::Baseのインスタンスを生成し、自前でHashに詰めて管理しているので、こんなに複雑になっているんだなということが分かった。</p>
<p>YARDの機能では拾いきれないもの (ローカル変数などに対する <code>@type</code> タグとか?) があってそのために自前でやっているのかな?</p><hr><p>Symbolの補完</p>
<ul>
<li>シンボルを入力しようとしていそうであれば補完する</li>
<li>そのプロジェクトに存在する全てのSymbol (リテラル?) を返す</li>
<li>Gemに含まれてるものは無視していい?</li>
</ul>
<p>YARD Tagの補完</p>
<ul>
<li>コメント内でかつタグっぽい場所であれば補完する</li>
<li>知っているすべての定数から補完</li>
<li>上手く検索するために検索器がそこそこ優秀なAPIを提供している</li>
</ul><hr><p>Cursorはsourceとpositionを保持するだけのあまり意味のない抽象かと思っていたものの、Cursor#start_of_constant? などを見ると必要そうな抽象かも。補完のコンテキストでよく出てくる。</p><hr><p>Closureというのは、コンテキストを作り得るノード (solargraphにおいてはPin) を表すようで、class, module, def, (block?) などがあるっぽい</p><hr><p>coreとstdlibのyardocを生成しておいて、それを起動時にデフォルトで読み込む、というのをやる必要がありそう。</p>]]></content:encoded></item><item><title><![CDATA[2022-08-21]]></title><description><![CDATA[r7kamura's working log on 2022-08-21]]></description><link>https://r7kamura.github.io/diary/articles/108</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/108</guid><pubDate>Sun, 21 Aug 2022 00:09:53 GMT</pubDate><content:encoded><![CDATA[<hr><p><img src="https://user-images.githubusercontent.com/111689/185770074-846d26d1-51b9-4e4c-aafd-fba5ba3f1d64.png" alt="image"></p>
<p>「カーソルが指しているノードの型が分かる場合はそれを返す」という実装をつくってみようとしている。</p>
<p>ソースコードとカーソル位置を与えると、カーソルの指しているノードと、そのコンテキストを作り出しているノード (ここでは <code>A#b</code>) を返す、という実装を試しにつくった。これはソースコードをパースして位置情報やノードの種類で走査すれば実現できた。</p>
<p>メソッドの仮引数である <code>foo</code> の型注釈はYARDから引いてこれるので、これらを結び付ければ導出できるはず。</p><hr><p>メソッド内の</p>
<ul>
<li>ローカル変数</li>
<li>レシーバーの無いメソッド呼び出し</li>
</ul>
<p>について、それぞれYARDで型注釈が与えられていないか調べにいって、あればそれを返すという実装ができた。</p>
<p><img src="https://user-images.githubusercontent.com/111689/185775606-714f6a39-2505-478f-bc2f-a7d712d97f37.png" alt="image"></p><hr><p>メソッドチェーンに再帰的に対応できた。</p>
<p>あとは対応するノードの種類を増やしていけば、YARDの注釈ベースで型を推測するという機能は完成しそう。</p><hr><p>次回対応したいもの</p>
<ul>
<li>local variable assignment</li>
<li>constant</li>
<li>singleton method</li>
</ul>]]></content:encoded></item><item><title><![CDATA[2022-08-20]]></title><description><![CDATA[r7kamura's working log on 2022-08-20]]></description><link>https://r7kamura.github.io/diary/articles/107</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/107</guid><pubDate>Fri, 19 Aug 2022 22:02:19 GMT</pubDate><content:encoded><![CDATA[<hr><p>Solargraphのソースコードを大体読みたいところを読み終わった。</p>
<ul>
<li>当初は、自前で似たものをつくってより深く学んでみようと考えていた</li>
<li>Solargraphのやっていることの規模が大きすぎて、自分で実装するには大変そうだった</li>
<li>仕組みは大体予想通り。やっていそうなことをやっていた</li>
<li>yard gemsがビルドしたファイルからデータを読み込んで集約し、それをMarshal.dumpでキャッシュしていた</li>
<li>Libraray, ApiMap, Pin, SourceMap, YardMap, Host</li>
<li>Inferの仕組みもやるべきことを淡々とやっている感じであった</li>
</ul>]]></content:encoded></item><item><title><![CDATA[2022-08-19]]></title><description><![CDATA[r7kamura's working log on 2022-08-19]]></description><link>https://r7kamura.github.io/diary/articles/106</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/106</guid><pubDate>Thu, 18 Aug 2022 21:31:56 GMT</pubDate><content:encoded><![CDATA[<hr><p>引き続きSolargraph</p><hr><h3>workspace</h3>
<p>プロジェクトのディレクトリに対して1つのWorkspaceが割り当てられる。</p>
<h3>library</h3>
<ul>
<li>1つのlibraryが1つのApiMapを持つ</li>
<li>1つのソースコードと対応している?
<ul>
<li>現在見ているソースコードという状態を持っているだけで、そうではないかも</li>
</ul>
</li>
<li>1つのworkspaceが複数のlibraryを持つ?
<ul>
<li>library belongs_to workspace という関係</li>
</ul>
</li>
<li>要請に応じて違反や定義元を返したりする役割も持っている</li>
</ul><hr><ol>
<li>エディタ起動時、エディタのworkspaceが <code>Host#prepare_folders</code> で読み込まれる</li>
<li>Solargraph::Library.loadでそのディレクトリの情報が用意される</li>
<li>Host#librariesに読み込んだ情報が登録される</li>
<li>エディタからのリクエストに応じて、Host#librariesが検索される</li>
</ol><hr><p>Library#find_external_requires という実装があった。そのソースコード内の <code>require</code> を集めているらしい。</p>
<p>bundlerの管理するgemのYARDはどう読み込まれているのか気になって調べてみた。
YardMapでrequire_from_bundleというのがあったので、Gemのソースは多分ここで読み込まれている。YardMapがどこから使われているかは不明。ApiMapがYardMapの参照を持っているので多分ApiMapが管理している。yard_mapは、definitionを調べるリクエストとtype checkから使われていた。</p><hr><p>Workspace#generate_require_paths を見ていると、gemspecが存在する場合は、それを読んでrequire_pathsの内容からどのファイルを読むべきか推測するというコードが書かれていた。デフォルトではlibになる。</p><hr><p>Workspace#initializeではそのディレクトリの配下のRubyのソースコードがほぼ全て読み込まれ、Solargraph::Sourceに変換される。</p><hr><p>Solargraphで定数をgo to definitionしたときには候補が沢山表示されるなと思っていたが、これはRubyがオープンクラスできるためで、その定数をnamespaceとして利用している実装が候補に上がるためである。solargraphは第一候補として一番それらしいやつを挙げてくれるようなので、大体のケースではF12を二回押すだけで事足りる。</p><hr><p>カーソル位置についての処理を担当するのがClipクラスらしい。</p><hr><p>ApiMapというのは、いろんなところでソースコードの集合を扱うための実装で、1つのLibraryが1つのApiMapを持っていたり…するらしいが概念がよく分からない...がlibraryが複数のソースコードを扱う存在であると考えるなら妥当かも。</p><hr><p>ApiMapが大きいやつで、SourceMapが小さいやつ…</p><hr><p>最初のステップとして、<code>@param</code> で仮引数の型が明示されている場合に、その仮引数の定義位置を返す、という機能を実装できるようにしてみるのはどうか。</p><hr><ol start="0">
<li>Solargraph::LanguageServer::Message::TextDocument::Definition 型を表すPinの配列からLSP用の位置情報を返す</li>
<li>Host#definitions_at</li>
<li>Library#definitions_at</li>
<li>Clip#define カーソル位置のチェーン (一連のまとまり) から推測される型を表すPinの配列を返す</li>
<li>Chain#define ほぼ同上</li>
<li>Chain#infer_first_defined 型の計算が行われる中核部分</li>
<li>Link#resolve 型を表すPinの配列を返す</li>
</ol>
<p>chain.linksのlinksはchainの要素で、a.b.cの場合linksはa, b, cみたいな感じ。</p>
<p>ApiMapをchainあたりまで引き回しているが、これはdatabase connectionみたいなもので、実際のソースコードの情報を色々引いてくるにはこうするのが妥当。</p>
<p>inferが結構大変そう。
例えば、メソッドの本体部分からreturn valueになり得るものを探してそのnodeの取り得る型をinferするとか。
infer無しでYARDの型定義だけ探して無ければ諦めるならまだマシそう。</p><hr><p>どこかで library.catalog が呼ばれて、そのタイミングで libarary.api_map の内容が更新される (ソースコードが読み込まれる?) と思うんだけど、いつどこで呼ばれるのか分かっていない。</p>
<p>CLIから呼ばれるときはそこで呼ばれてるんだけど、Language Serverから呼ばれるときは… Host#catalog で呼ばれていた。あとスレッドを立てて、0.01秒sleepしながら一生catalogを呼び出し続けていた。DidChangeWatchedFiles命令でも呼び出している。起動時にも呼び出していると思うのだが…これはその別スレッドが呼び出すのだろう。</p>]]></content:encoded></item><item><title><![CDATA[2022-08-18]]></title><description><![CDATA[r7kamura's working log on 2022-08-18]]></description><link>https://r7kamura.github.io/diary/articles/105</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/105</guid><pubDate>Wed, 17 Aug 2022 21:33:05 GMT</pubDate><content:encoded><![CDATA[<hr><p>solargraph gemのソースコードを読んでいく。</p><hr><p>vscodeの方はほぼ何もしておらず、コマンドをサーバーに送信しているだけだった。</p>
<ul>
<li><a href="https://github.com/castwide/solargraph">https://github.com/castwide/solargraph</a></li>
<li><a href="https://github.com/castwide/vscode-solargraph">https://github.com/castwide/vscode-solargraph</a></li>
</ul><hr><p>solargraphの方では、Host#prepare(directory)でHost#librariesにSolargraph::Librariesを溜めておき、Host#diagnoseでこれに問い合わせている。</p><hr><p>Host#diagnoseの実装はLibrary#diagnoseに委譲されていた。更に、Diagnostics::Reporter.reporter(name)に委譲されている。</p><hr><p>Diagnostics::Rubocopに辿り着いた。これはReporterの1つで、他にはTypeCheckなどがあるらしい。</p><hr><p>lib/solargraph/diagnostics/rubocop.rb を見た。vscode-ruby-lightとやっていることはほぼ同じだった。</p><hr><p>Diagnosticsを読むのは終えて、Documentというのを読んでみることに。これはHost#document -> Library#document -> ApiMap#document と委譲されている。</p><hr><p>vscode-ruby-lightのおかげで手軽にRubyのソースコードのシンボル情報を得られるようになって、メソッド名で検索するというのがやりやすくなって捗るようになった。</p><hr><p><code>api_map.clip(cursor).complete</code> でその地点の補完候補を返しているようなので、これを読んでみる。</p><hr><p>インライン化すると <code>SourceMap::Clip.new(self, cursor).complete</code> になる。</p><hr><pre><code class="language-ruby"># @return [Completion]
def complete
  return package_completions([]) if !source_map.source.parsed? || cursor.string?
  return package_completions(api_map.get_symbols) if cursor.chain.literal? &#x26;&#x26; cursor.chain.links.last.word == '&#x3C;Symbol>'
  return Completion.new([], cursor.range) if cursor.chain.literal?
  if cursor.comment?
    tag_complete
  else
    code_complete
  end
end
</code></pre><hr><p>cursor.chainで使われているChainは、メソッドチェーンなどの一連のトークン列を表すやつ? トークン、と読み替えても差し支えない気がする。chain.linksはtoken.previous_tokens。</p>
<p>そうなると、</p>
<pre><code class="language-ruby">  return package_completions(api_map.get_symbols) if cursor.chain.literal? &#x26;&#x26; cursor.chain.links.last.word == '&#x3C;Symbol>'
</code></pre>
<p>これは、現在カーソルがSymbolリテラルを指しているときは、Symbol一覧の補完候補を出しましょうということになる。libraryに問い合わせていて、libraryは1つのファイルについての情報のみを持っているはずだから、これは「現在ファイル内のSymbolから補完候補を出す」ということになりそう。</p>
<p>ところで、単純なワードだけを補完するのであれば、VSCodeの標準機能がそれを補完候補に含めてくれるはずなので、実際これは意味があるんだろうか...? 補完候補の優先順位が上がるとかだろうか。</p><hr><pre><code>solargraph socket --host 0.0.0.0
</code></pre>
<p>とやることでWSL環境でもsolargraphが動いた。これをしないと動かない……デフォルトだと127.0.0.1になってこれがWSLだと動かない (別のもの...Windows側のホスト?に解決される?) のだと推測している。</p>
<p><img src="https://user-images.githubusercontent.com/111689/185257843-4fc4893a-5096-4183-98b8-fd7353042181.png" alt="image"></p>
<p>引数にhoverするとツールチップが表示されて、リンクっぽい文字列をクリックするとwebviewというやつが開くことが確認できた。webviewを使ってドキュメント表示を実現しているらしい。ドキュメントの計算には時間が掛かるから、1ステップ踏ませている、という努力が見られる気がする。</p><hr><p>stdioモードにしたら上手く動いた。</p><hr><p>vscode-solargraphを見ると、stdioモードの場合は起動時にクライアント側でsolargraph stdioをspawnしている様子が見て取れた。extentionKindがworkspaceなので、当然クライアント側で起動してもOK。</p><hr><p>typecheckerは面白いけど、YARD viewerみたいなものがあればそれで十分かなあ。</p>
<pre><code class="language-ruby"># @params [Foo::Bar] bar
</code></pre>
<p>に対して、Rubyで <code>Foo::Bar</code> の定義元を調べたりメソッドの情報を調べたりできるともっと便利だけど、これは実行してみないといけないので、適切にrequireしたりする必要があって色々大変かも。</p><hr><p>vscode-ruby-lightにYARD Viewer機能をつくってみてもいいかも。できるところまでシグネチャを解析して、ビルドされたYARDのデータベースに一致すればその情報を返すというもの。</p>
<p>あとデフォルトで標準ライブラリについての情報は持っておいてもいいかも。そうなるとYARDに限らない気もするけど。</p><hr><p>もうしばらくsolargraphのコードを読んでいく。</p>
<p>Pin, SourceMap, ApiMap辺りの概念を把握する必要がありそう。</p><hr><p>コード上のオブジェクトのことをPinと呼ぶようだ。例えば、一つの派生形として、Pin::Methodがある。</p>]]></content:encoded></item><item><title><![CDATA[2022-08-17]]></title><description><![CDATA[r7kamura's working log on 2022-08-17]]></description><link>https://r7kamura.github.io/diary/articles/104</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/104</guid><pubDate>Tue, 16 Aug 2022 21:06:14 GMT</pubDate><content:encoded><![CDATA[<hr><p>Style/FormatStringTokenは、特定のメソッドの引数やレシーバーのときのみ動作するようにしても良いんじゃないかと思った。それから、autocorrectできそうなコンテキストでしない場合があるので、これは直したいかも。</p><hr><p>vscode-ruby-lightにYARDサポートを入れてもいいかもしれない。
yard gemsとyriを使ってみたら何かできそうな気がした</p>
<ul>
<li><a href="https://github.com/lsegal/yard">https://github.com/lsegal/yard</a></li>
</ul><hr><p>solargraphのソースコードを読んでみることにする。</p>]]></content:encoded></item><item><title><![CDATA[2022-08-16]]></title><description><![CDATA[r7kamura's working log on 2022-08-16]]></description><link>https://r7kamura.github.io/diary/articles/103</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/103</guid><pubDate>Tue, 16 Aug 2022 00:27:22 GMT</pubDate><content:encoded><![CDATA[<hr><p><a href="https://r7kamura.com/articles/2022-08-16-vscode-ruby-light">Ruby用VSCode拡張: vscode-ruby-light</a>を書いた。</p>]]></content:encoded></item><item><title><![CDATA[2022-08-15]]></title><description><![CDATA[r7kamura's working log on 2022-08-15]]></description><link>https://r7kamura.github.io/diary/articles/102</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/102</guid><pubDate>Mon, 15 Aug 2022 01:48:52 GMT</pubDate><content:encoded><![CDATA[<hr><p>vscode-ruby-lightのrubocopの機能を使うにはDocker越しではいけないので、devcontainerで開発てしみる実験を始めた。</p>
<p>何故か普通にセットアップして起動しようとすると起動できないのだが、別途 docker-compose up -d rails と起動してやるとrialsサービスにattachしながらVSCodeが起動できるという状態。これは自前でやることなしに上手くできてほしい…… vscodeの実行するコマンドでrailsサービスが適切に指定されてほしい気がする。</p><hr><p>ともあれ上手くいった。</p>
<p>自分で入れたghコマンドのauthを通すにはどうしたらいいか考えていたのだけど、ホスト側から ~/.config/gh/hosts.yml をマウントしてあげるのが良さそうだった。これはリポジトリには入れられないので、docker-compose.override.yml のvolumesの設定に書いてattachしてもらうしかないかも。</p>
<ul>
<li><a href="https://github.com/cli/cli/discussions/3226">https://github.com/cli/cli/discussions/3226</a></li>
</ul><hr><p>services.rails.depends_onに指定されているやつをrunServicesに指定したら上手く動いた。これ指定しないといけないのかあ。</p>
<pre><code class="language-json">{
  "name": "Rails",
  "dockerComposeFile": [
    "../docker-compose.yml"
  ],
  "service": "rails",
  "runServices": [
    "elasticsearch",
    "mysql",
    "redis"
  ],
  "workspaceFolder": "/workspace"
}
</code></pre><hr><p>docker-compose.override.yml はわざわざ指定しなくてもちゃんと読み込んでくれるっぽい。単純にVSCodeもdocker-composeコマンドを実行しているだけなので当たり前ではあるか。</p><hr><pre><code class="language-json">{
  "name": "Rails",
  "dockerComposeFile": [
    "../docker-compose.yml"
  ],
  "service": "rails",
  "runServices": [
    "rails"
  ],
  "workspaceFolder": "/workspace"
}
</code></pre>
<p>こう書いてもいけそうだ。</p><hr><p>一度VSCodeのworkspaceを閉じて再度開いてReopen containerするだけではdotfilesは再インストールしてくれないみたいだ。</p><hr><p>Git 2.22の機能を使っていたが、Git 2.20が入っていて面倒だったので、それに対応する.bashrcに差し替えたという経緯。</p>
<pre><code>cd /root/dotfiles
git pull
cd -
source ~/.bashrc
</code></pre>
<p>で解決させた。</p><hr><p>ssh-agentが動いていないのでgit pushなどがhang outする問題のことを忘れていてまた遭遇した。が対処方法を覚えていたので、keychainを使って勝手にssh-agentが起動するようにした。</p>]]></content:encoded></item></channel></rss>