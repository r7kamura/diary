<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[r7kamura/diary]]></title><description><![CDATA[r7kamura's daily working log.]]></description><link>https://r7kamura.github.io/diary/</link><generator>r7kamura/diary</generator><lastBuildDate>Tue, 27 Sep 2022 19:10:20 GMT</lastBuildDate><atom:link href="https://r7kamura.github.io/diary/feed.xml" rel="self" type="application/rss+xml"/><item><title><![CDATA[2022-09-21]]></title><description><![CDATA[r7kamura's working log on 2022-09-21]]></description><link>https://r7kamura.github.io/diary/articles/127</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/127</guid><pubDate>Tue, 20 Sep 2022 21:13:18 GMT</pubDate><content:encoded><![CDATA[<hr><p>Issueに適切なキーワードを付け、トピックベースで記録を残していった方が有益かもしれない……という考えが生じ、NotionやScrapboxについて再考したり、Digital Gardeningに関係する記事群を読み漁ったりしていたら、すっかりここdiaryに記録を執らなくなってしまっていた。</p><hr><p><a href="https://github.com/r7kamura/scrap">r7kamura/scrap</a>というリポジトリを新たに用意し、実験としてトピックベースでそこに記録を残す活動を試してみることにした。</p><hr><p>トピックベースだと、日記形式と違って、トピックが立てられないような取り留めの無いものが溢れていく可能性が高いけど、それは捨てる勇気を持って捨てた方が良い物事なのかもしれない。</p>]]></content:encoded></item><item><title><![CDATA[2022-09-11]]></title><description><![CDATA[r7kamura's working log on 2022-09-11]]></description><link>https://r7kamura.github.io/diary/articles/126</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/126</guid><pubDate>Sun, 11 Sep 2022 04:32:34 GMT</pubDate><content:encoded><![CDATA[<hr><p>Rucoaの補完機能がほぼほぼ実装できた。</p>
<ul>
<li><a href="https://github.com/r7kamura/rucoa/pull/27">r7kamura/rucoa#27</a></li>
</ul>
<p>メソッドの補完ができる。定数の補完もしたいので、それが完成したらMergeする予定。メソッドや定数の定義を探索する部分で継承関係にまだ対応できていなかったりするので、それが今後の課題。まずは動くようにしてから、徐々にやりたいことを見つけられるようにして改善していこうという優先順位で進めている。</p><hr><p>r7kamura/diaryのWebページへの配信タイミングを、コメントごとではなく日次に変えた。</p>
<ul>
<li>Commitの数が無駄に増える</li>
<li>RSSは日次で前日分を一気に吐き出してるので揃えた方が違和感が無い</li>
<li>writeとreadはリアルタイムで繋がっているより少し分かれているぐらいの方が心地良い</li>
</ul>
<blockquote>
<p>writeとreadはリアルタイムで繋がっているより少し分かれているぐらいの方が心地良い</p>
</blockquote>
<p>これはもしかしたら重要な感覚かもしれない。Twitterとかにも何か適用できる要素のある考え方かもしれないが上手くまとまらないのでこれ以上掘り下げるのはやめることに。</p>]]></content:encoded></item><item><title><![CDATA[2022-09-10]]></title><description><![CDATA[r7kamura's working log on 2022-09-10]]></description><link>https://r7kamura.github.io/diary/articles/125</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/125</guid><pubDate>Fri, 09 Sep 2022 20:41:40 GMT</pubDate><content:encoded><![CDATA[<hr><p>ここ3日間ほど、気負いすぎて作業ログを書けていなかった。</p>
<p>作業ログを書くこと自体に疑問を持ち始めると途端に書けなくなるらしい。書き続けたいのであれば、特に何も考えずにやる方が良さそうではある。癖として書いているぐらいでちょうどいいかもしれない。</p><hr><p>今日はLanguage Serverの実装中にハマった。</p>
<p>いつかそうなるだろうと思ってたんだけどね。いまのLanguage Serverの実装ではIPCではなく標準入出力経由で通信することにしているんだけど、外部ライブラリのYARDが不正なタグを見つけたときに標準出力に警告を出力するものだから、パース中に意図せず警告がクライアントが読み込む標準出力に書き込まれてしまうことがあり、そこでクライアントが停止……というかそれ以上何も読み込めなくなるという問題が起きた。実際、エラーを吐くでもなく何か特定の操作をしたあとは機能が上手く働かなくなるという状況だったので、原因究明が遅れた。</p>
<p>デバッグもより難しいものになるし、標準入出力を使うのはやめてIPC経由で通信するように変更したいが、Rubyだとどうやるのが良いのかよく分かっていない。</p><hr><p>My name is Ryo. (私の名前はRyoです) って日常会話では全く言わないんだなあ。</p>
<p>I'm Ryo. (Ryoです。) が適切なシーンがほとんど。I am Ryo (私はRyoです。) とも言わない。実際のところ「私は◯◯です」という発言を日常会話でしないし、I'm Xが定型句と化しているから言わないらしい。日本語に当てはめてみると確かにそうで、私の名前はRyoです、なんて実際に発言することになるシーンなんてのはかなり限定的である。</p><hr><p>長時間の集中は1日に1度しか保てないようだ。</p>
<p>ここ100日以上、毎朝6時から6時間配信しながら集中して勉強する取り組みを続けているけれど、配信終了後に昼食を摂って更に何か勉強をする、という試みはあまり成功した回が無かった。やるぞという意気込みで午後に勉強していた回はなくて、どれもやりかけのものの続きに着手するという感じでダラダラ続けているという感じだったので比較にならないかもしれないが。</p>
<p>一方6時から15時まで勉強をするという試みも数十回ほど試していて、これは集中できていたように思う。集中にも摩擦みたいなものがあって、完全に集中していない状態から集中に入る段階が一番難しいところだから、それが2回発生するというのは無駄が大きいという認識をしている。いま6時から12時までしか勉強していないのは、9時間が長すぎてもたない訳ではなくて、残りの1日の可処分時間が9時間から6時間に減ることを憂慮しているという点と、6時間程度どその日にやりたいことを終わらせるようなよりハードな目標設定にした方がより上手く集中できるだろうという点からそうしているる</p>]]></content:encoded></item><item><title><![CDATA[2022-09-06]]></title><description><![CDATA[r7kamura's working log on 2022-09-06]]></description><link>https://r7kamura.github.io/diary/articles/124</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/124</guid><pubDate>Tue, 06 Sep 2022 11:38:08 GMT</pubDate><content:encoded/></item><item><title><![CDATA[2022-09-05]]></title><description><![CDATA[r7kamura's working log on 2022-09-05]]></description><link>https://r7kamura.github.io/diary/articles/123</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/123</guid><pubDate>Sun, 04 Sep 2022 23:46:41 GMT</pubDate><content:encoded><![CDATA[<hr><p>Added Range Formatting support and some bug fixes to rucoa, the language server implementation I'm recently working on.</p>
<ul>
<li><a href="https://github.com/r7kamura/rucoa">https://github.com/r7kamura/rucoa</a></li>
</ul>
<p>The next plan is to add some configuration so that users can disable some features or the entire features in their workspace in case.</p><hr><p>この日記も作業ログとしてただ書き連ねているけど、TIL (Today I Learned) 寄りの表現で書いた方が自分にとって良いような気がしてきている。というのも、人に教える体裁で記述して始めて身に付いている実感が付くためだ。また副次的効果として、単純に作業ログが書き連ねられているよりも、たまたまこの文章を見かける第三者にとって、幾分読みやすいものになるだろうという淡い目論見もある。</p><hr><p>今日は書籍 "Clean Craftsmanship" を読み終えた。これ系の書籍の総集編まとめ令和最新版という内容だった。Clean Codeとかアジャイル何とかを読んだことがある人にとっては、大体同じようなことが書いてあるように感じられるかもしれない。著者自身もそのように語っていた。</p><hr><p>本書はTDD激推しの本で、一言でいうと、テストの重要性を2022年の見地からあらためてまとめてくれた本。</p>
<p>テストの効能として、主にプログラムの本質を見つけ出していくための道具としての側面と、プログラマーが規律を示すための道具としての側面の二つに分けて説明がなされているように思う。</p>
<p>規律の話に関して、TDDというのは会計における複式簿記と同じものであるという認識が語られていた。実装とテストとがバランスシート構成するような関係性になっている。複式簿記は数百年前に発明され、現在ではそれが法律上で運用される程度には深く浸透している。テストもソフトウェア開発においてはそれに近い存在となっていくだろうという話。</p>
<p>いまはソフトウェア開発は混沌とした状況で、不具合が含まれていて当たり前みたいな状況だけれど、社会のソフトウェアへの依存は増すばかりであり、ソフトウェアの不具合が社会に及ぼす影響が近いうちに無視できない規模にまで膨れ上がっているということに、人々が気付き始めるだろう。そして、しっかりとしたテストの必要性が大きく叫ばれるようになっていき、それをつくるプログラマーには規律が求められるようになっていくだろう。そうなっていくと、テストが徐々にバランスシートのような扱いになっていくだろうし、プログラマーはよりテストに重きを置くようにせねばならない、という話だった。</p>]]></content:encoded></item><item><title><![CDATA[2022-09-04]]></title><description><![CDATA[r7kamura's working log on 2022-09-04]]></description><link>https://r7kamura.github.io/diary/articles/122</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/122</guid><pubDate>Sun, 04 Sep 2022 03:14:58 GMT</pubDate><content:encoded><![CDATA[<hr><p>rucoaの実装を1日でかなり進めた。vscode-ruby-lightとほぼ同等程度の機能に追いついたはず。</p>]]></content:encoded></item><item><title><![CDATA[2022-09-03]]></title><description><![CDATA[r7kamura's working log on 2022-09-03]]></description><link>https://r7kamura.github.io/diary/articles/121</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/121</guid><pubDate>Fri, 02 Sep 2022 21:08:44 GMT</pubDate><content:encoded><![CDATA[<hr><p>Clean Craftsmanshipを引き続き読んでいる。3章のTDD応用の話から。</p><hr><p>TDDは、実装する必要のある物事を、段階的かつ滑らかに、小さな実装の連続として分解していくためのアルゴリズムとして有用である、的なことを言いたいように思える。</p><hr><p>xUnit Patterns (2007) によりテストダブルと定義付けられたもの……には</p>
<ul>
<li>ダミー</li>
<li>スタブ</li>
<li>スパイ</li>
<li>モック</li>
<li>フェイク</li>
</ul>
<p>がある。いつもどれがどれか思い出せずにいたのだが (というか名前を知らないが機能は使っている状態だった)、どうやら継承関係があるらしい。</p>
<pre><code>モック &#x3C; スパイ &#x3C; スタブ &#x3C; ダミー &#x3C; テストダブル
フェイク &#x3C; テストダブル
</code></pre><hr><p>テスト対象によっては、テストパターンを追加しても条件を絞り込めないものがある。その例として、sin関数の例が紹介されていた。確かに、sin(0) をテストしたからといって何か仕組みが明らかになっていく感じがしない。</p><hr><p>My YouTube channel reached out 400 subs :tada:</p><hr><p>Ruby向けにNode.js製のLanguage Serverでリッチな編集体験を提供するのは諦めて、結局RubyでLanguage Serverを実装することにした。</p>
<ul>
<li><a href="https://github.com/r7kamura/rucoa">https://github.com/r7kamura/rucoa</a></li>
</ul>]]></content:encoded></item><item><title><![CDATA[2022-09-02]]></title><description><![CDATA[r7kamura's working log on 2022-09-02]]></description><link>https://r7kamura.github.io/diary/articles/120</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/120</guid><pubDate>Thu, 01 Sep 2022 23:24:55 GMT</pubDate><content:encoded/></item><item><title><![CDATA[2022-09-01]]></title><description><![CDATA[r7kamura's working log on 2022-09-02]]></description><link>https://r7kamura.github.io/diary/articles/119</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/119</guid><pubDate>Thu, 01 Sep 2022 23:24:12 GMT</pubDate><content:encoded><![CDATA[<hr><p>Clean Craftsmanshipを読み始めた。いまは17%ぐらい。</p>]]></content:encoded></item><item><title><![CDATA[2022-08-31]]></title><description><![CDATA[r7kamura's working log on 2022-08-31]]></description><link>https://r7kamura.github.io/diary/articles/118</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/118</guid><pubDate>Tue, 30 Aug 2022 21:49:03 GMT</pubDate><content:encoded><![CDATA[<hr><p>寝ている間にきていた分のOSSのレビューにはすべて対応し終えた。</p>]]></content:encoded></item><item><title><![CDATA[2022-08-30]]></title><description><![CDATA[r7kamura's working log on 2022-08-30]]></description><link>https://r7kamura.github.io/diary/articles/117</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/117</guid><pubDate>Mon, 29 Aug 2022 21:10:32 GMT</pubDate><content:encoded><![CDATA[<hr><p>20件の動画のタイトルと再生リストを修正するにあたり、YouTube APIを使うか迷った結果、手作業でやることにした。</p>]]></content:encoded></item><item><title><![CDATA[2022-08-29]]></title><description><![CDATA[r7kamura's working log on 2022-08-29]]></description><link>https://r7kamura.github.io/diary/articles/116</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/116</guid><pubDate>Mon, 29 Aug 2022 03:00:15 GMT</pubDate><content:encoded><![CDATA[<hr><p>YouTube APIを使って2つの再生リストをmergeすることにした。</p>]]></content:encoded></item><item><title><![CDATA[2022-08-28]]></title><description><![CDATA[r7kamura's working log on 2022-08-28]]></description><link>https://r7kamura.github.io/diary/articles/115</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/115</guid><pubDate>Sat, 27 Aug 2022 22:33:47 GMT</pubDate><content:encoded><![CDATA[<hr><p>定数の補完に取り組んでいる。</p><hr><p><img src="https://user-images.githubusercontent.com/111689/187054811-124130a3-64c8-4d6d-ab1b-930f01352470.png" alt="image"></p>
<p>実装の隣にテストが書いているの、下手なテキストが書かれているよりよほど分かりやすいような気がする</p>]]></content:encoded></item><item><title><![CDATA[2022-08-27]]></title><description><![CDATA[r7kamura's working log on 2022-08-27]]></description><link>https://r7kamura.github.io/diary/articles/114</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/114</guid><pubDate>Fri, 26 Aug 2022 22:36:05 GMT</pubDate><content:encoded><![CDATA[<hr><p>RubyのコアはRDocでドキュメントが記載されているが、型情報についてはここには記載されないようだった。つまり公式のRDocからデータを読み取って利用する作戦は失敗。</p>
<p>RBSだと型情報が取れる上に公式のRDocから抽出したコメントも併記されているので、代わりにRBSの情報を使うのが良さそうに見える。</p><hr><p>ruby/rubyのRDocではなくruby/rbsのRBSの情報を元にするように変更できた。</p>
<p>YARDと型の表現方法が違ったりする部分の吸収については頑張らないといけない。</p>
<pre><code># RBS
::Array[::String]

# YARD
Array&#x3C;String>
::Array&#x3C;::String> も可
</code></pre><hr><pre><code class="language-ruby">def foo
  bar.
end
</code></pre>
<p>のような書きかけのコードに対して、一時的に情報を補完してパースした上で解析を試みる、という実験が上手くいった。これで補完候補を出せるようになった。このような事情を考えると、エラーに対して問題を最低限の形に押し留めて修復可能なパーサーの登場が望まれる。</p>]]></content:encoded></item><item><title><![CDATA[2022-08-26]]></title><description><![CDATA[r7kamura's working log on 2022-08-26]]></description><link>https://r7kamura.github.io/diary/articles/113</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/113</guid><pubDate>Fri, 26 Aug 2022 07:50:22 GMT</pubDate><content:encoded><![CDATA[<hr><p>型システムの改善を行い、AST中のノードから色々な情報を簡単に取得できるようにした。</p>
<p><img src="https://user-images.githubusercontent.com/111689/186851471-85d08fba-bd47-4d9f-ad63-15e363b9104e.png" alt="image"></p>
<p>いまの課題は、カーソル位置に対して適切な補完候補を出すというもの。単純にパースしようとするとSyntaxErrorになるので、SyntaxErrorになった場合、ならなかった場合とで条件分岐して、なった場合の処理を考える必要がある。ならなかった場合の処理は簡単。</p><hr><p>システムが扱う範囲が型の分野を超えていて、コード解析機という感じになってきた。</p>]]></content:encoded></item><item><title><![CDATA[2022-08-25]]></title><description><![CDATA[r7kamura's working log on 2022-08-25]]></description><link>https://r7kamura.github.io/diary/articles/112</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/112</guid><pubDate>Wed, 24 Aug 2022 21:03:43 GMT</pubDate><content:encoded><![CDATA[<hr><p><img src="https://user-images.githubusercontent.com/111689/186552075-0d7059d6-4a2c-4df1-90a9-4c34cecddc34.png" alt="image"></p>
<p>往年のアスキーアートっぽい</p><hr><p><img src="https://user-images.githubusercontent.com/111689/186552121-12495059-40a3-46a5-9a6e-30e16a321bc1.png" alt="image"></p>
<p>Ruby本体のソースコードから定義を読み取る実験が上手く成功した。</p>]]></content:encoded></item><item><title><![CDATA[2022-08-24]]></title><description><![CDATA[r7kamura's working log on 2022-08-24]]></description><link>https://r7kamura.github.io/diary/articles/111</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/111</guid><pubDate>Tue, 23 Aug 2022 22:20:16 GMT</pubDate><content:encoded><![CDATA[<hr><p>RDocを使ってRubyのソースコードをパースし、定義を記した適当なオブジェクトを得る実験に成功した。</p>
<p>これをYARD::CodeObjects::Baseに変換して取り回すか、あるいはRDocとYARDの両方を束ねるオブジェクトに変換するか、いずれかの方法を取らねばならない。</p><hr><p>RBS等、他のドキュメント形式にも今後対応する必要が出てくるかもしれないので、arts側で仕様を定めたオブジェクトをつくり、それにまとめていくという方がまともだと考えている。</p>]]></content:encoded></item><item><title><![CDATA[2022-08-23]]></title><description><![CDATA[r7kamura's working log on 2022-08-23]]></description><link>https://r7kamura.github.io/diary/articles/110</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/110</guid><pubDate>Tue, 23 Aug 2022 00:25:36 GMT</pubDate><content:encoded><![CDATA[<hr><p>Ruby core &#x26; stdlibのyardocをそれぞれ生成して読み込むことに生成したが、そこには <code>@return</code> みたいなタグが書かれているわけではないので、返り値が計算できない。</p><hr><p>YARDがRubyのコア機能に対して生成するドキュメントには返り値の情報が含まれていないから、てっきり元々書かれていないのかと思いきや、RDocから生成されているはずの <a href="https://docs.ruby-lang.org/en/3.1/Integer.html#method-i-chr">https://docs.ruby-lang.org/en/3.1/Integer.html#method-i-chr</a> を見てみると、情報があるように見える。変換に対応していないだけか?...と思いきや、YARDにlib/yard/parser/c/comment_parser.rbというのがあって、<code>-> true or false</code> をBooleanに変換するロジックなどを持っていた。</p><hr><p>C由来の情報はYARD::Registry.allで取得しようとすると一部欠落する?</p><hr><p>C由来のコメントはoverload tagとして表現されていて、tag.tags(:overload).first.tags(:return) とかやると出てくるみたいだった。</p><hr><p>Ruby 3.1でRubyのソースコードのRDocのcall-sequenceの書き方に変更があったみたいで、YARD::Parser::C::CommentParserが上手くパースできず、何も情報を抽出できない状態となっていた。Ruby 3.0まではレシーバー無しで記述していたのが、Ruby 3.1からはレシーバー付きで記述するようになり、こうなった模様。</p>
<p>上手くやるには、RDocのパーサーを使ってYARDの情報を生成する、という風に書き換えないといけなさそう。あるいはRuby 3.0以下のソースコードからドキュメントを生成する。本当にRuby 3.0ですべてが上手くパースできるのかは怪しいので、RDocのパーサーを使えないか検討することにも依然として価値があるとは思う。</p>]]></content:encoded></item><item><title><![CDATA[2022-08-22]]></title><description><![CDATA[r7kamura's working log on 2022-08-22]]></description><link>https://r7kamura.github.io/diary/articles/109</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/109</guid><pubDate>Mon, 22 Aug 2022 00:33:20 GMT</pubDate><content:encoded><![CDATA[<hr><p>vscode-solargraph、たまにdocument highlightが壊れてエラーのポップアップを右下に出し続ける状態になるので、そこは体験が悪い</p><hr><p>型の特定ができるようになってきたので、今度はこれを利用する補完の提案機能をつくってみようと思う</p><hr><p>solargraphはYARDのパース機能を使わず、自前でソースコードをコメントと一緒にパースしながら、自前でYard::CodeObject::Baseのインスタンスを生成し、自前でHashに詰めて管理しているので、こんなに複雑になっているんだなということが分かった。</p>
<p>YARDの機能では拾いきれないもの (ローカル変数などに対する <code>@type</code> タグとか?) があってそのために自前でやっているのかな?</p><hr><p>Symbolの補完</p>
<ul>
<li>シンボルを入力しようとしていそうであれば補完する</li>
<li>そのプロジェクトに存在する全てのSymbol (リテラル?) を返す</li>
<li>Gemに含まれてるものは無視していい?</li>
</ul>
<p>YARD Tagの補完</p>
<ul>
<li>コメント内でかつタグっぽい場所であれば補完する</li>
<li>知っているすべての定数から補完</li>
<li>上手く検索するために検索器がそこそこ優秀なAPIを提供している</li>
</ul><hr><p>Cursorはsourceとpositionを保持するだけのあまり意味のない抽象かと思っていたものの、Cursor#start_of_constant? などを見ると必要そうな抽象かも。補完のコンテキストでよく出てくる。</p><hr><p>Closureというのは、コンテキストを作り得るノード (solargraphにおいてはPin) を表すようで、class, module, def, (block?) などがあるっぽい</p><hr><p>coreとstdlibのyardocを生成しておいて、それを起動時にデフォルトで読み込む、というのをやる必要がありそう。</p>]]></content:encoded></item><item><title><![CDATA[2022-08-21]]></title><description><![CDATA[r7kamura's working log on 2022-08-21]]></description><link>https://r7kamura.github.io/diary/articles/108</link><guid isPermaLink="true">https://r7kamura.github.io/diary/articles/108</guid><pubDate>Sun, 21 Aug 2022 00:09:53 GMT</pubDate><content:encoded><![CDATA[<hr><p><img src="https://user-images.githubusercontent.com/111689/185770074-846d26d1-51b9-4e4c-aafd-fba5ba3f1d64.png" alt="image"></p>
<p>「カーソルが指しているノードの型が分かる場合はそれを返す」という実装をつくってみようとしている。</p>
<p>ソースコードとカーソル位置を与えると、カーソルの指しているノードと、そのコンテキストを作り出しているノード (ここでは <code>A#b</code>) を返す、という実装を試しにつくった。これはソースコードをパースして位置情報やノードの種類で走査すれば実現できた。</p>
<p>メソッドの仮引数である <code>foo</code> の型注釈はYARDから引いてこれるので、これらを結び付ければ導出できるはず。</p><hr><p>メソッド内の</p>
<ul>
<li>ローカル変数</li>
<li>レシーバーの無いメソッド呼び出し</li>
</ul>
<p>について、それぞれYARDで型注釈が与えられていないか調べにいって、あればそれを返すという実装ができた。</p>
<p><img src="https://user-images.githubusercontent.com/111689/185775606-714f6a39-2505-478f-bc2f-a7d712d97f37.png" alt="image"></p><hr><p>メソッドチェーンに再帰的に対応できた。</p>
<p>あとは対応するノードの種類を増やしていけば、YARDの注釈ベースで型を推測するという機能は完成しそう。</p><hr><p>次回対応したいもの</p>
<ul>
<li>local variable assignment</li>
<li>constant</li>
<li>singleton method</li>
</ul>]]></content:encoded></item></channel></rss>